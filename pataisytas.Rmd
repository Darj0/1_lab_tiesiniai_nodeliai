


---
title: "tm1lab"
author: "vilte"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}

#data <- read.csv("/Users/darjabaranova/Documents/VU/3_kursas/tiesiniai_metodai/CO2 Emissions_Canada.csv", header = TRUE)
data <- read.csv("C:/Users/meliu/Desktop/TM/CO2_Emissions_Canada.csv", header = TRUE)

data <- data[, - (ncol(data) - 1)]

data$logCO2 <- log(data$CO2.Emissions.g.km.)
names(data) <- c("Markė",
                 "Modelis",
                 "Kėbulo tipas",
                 "Variklio tūris (l)",
                 "Cilindrų skaičius",
                 "Pavarų dėžės tipas",
                 "Kuro tipas",
                 "Kuro sąnaudos mieste (l/100km)",
                 "Kuro sąnaudos greitkelyje (l/100km)",
                 "Vidutinės kuro sąnaudos (l/100km)",
                 "Vidutinės kuro sąnaudos (mpg)",
                 "CO2 emisijos (g/km)")


data$"Kėbulo tipas" <- with(data,
  ifelse(`Kėbulo tipas` %in% c("SUV - SMALL", "SUV - STANDARD"), "SUV",
  ifelse(`Kėbulo tipas` %in% c("MID-SIZE", "COMPACT", "SUBCOMPACT", 
                               "MINICOMPACT", "FULL-SIZE", "TWO-SEATER"),
         "Lengvieji automobiliai",
  ifelse(`Kėbulo tipas` %in% c("STATION WAGON - SMALL", "STATION WAGON - MID-SIZE"),
         "Universalai",
  ifelse(`Kėbulo tipas` %in% c("PICKUP TRUCK - SMALL", "PICKUP TRUCK - STANDARD"),
         "Pikapai",
  ifelse(`Kėbulo tipas` %in% c("MINIVAN", "VAN - PASSENGER", "VAN - CARGO"),
         "Vienatūriai",
  ifelse(`Kėbulo tipas` == "SPECIAL PURPOSE VEHICLE", 
         "Specialieji", NA)))))))


data$"Pavarų dėžės tipas" <- ifelse(grepl("^AM", data$`Pavarų dėžės tipas`), "Automatizuota mechaninė",
                             ifelse(grepl("^AS", data$`Pavarų dėžės tipas`), "Automatinė su rankiniu perjungimu",
                             ifelse(grepl("^AV", data$`Pavarų dėžės tipas`), "Bepakopė (CVT)",
                             ifelse(grepl("^A",  data$`Pavarų dėžės tipas`), "Automatinė",
                             ifelse(grepl("^M",  data$`Pavarų dėžės tipas`), "Mechaninė", NA)))))


data$"Kuro tipas" <- ifelse(data$`Kuro tipas` == "X", "Įprastas benzinas",
                     ifelse(data$`Kuro tipas` == "Z", "Aukštos kokybės benzinas",
                     ifelse(data$`Kuro tipas` == "D", "Dyzelinas",
                     ifelse(data$`Kuro tipas` == "E", "Etanolis (E85)",
                     ifelse(data$`Kuro tipas` == "N", "Gamtinės dujos", NA)))))

# Išrenkam Top 10 markių duomenis
top10 <- names(sort(table(data$Markė), decreasing = TRUE))[1:min(10, length(unique(data$Markė)))]

data <- subset(data, Markė %in% top10)

```

```{r}
# Duomenų išvalymas:

# Patikrinam, kiek yra NA reikšmių
colSums(is.na(data))

# Funkcija, kuri patikrina išskirtis pagal IQR
check_outliers <- function(x, coef = 1.5) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - coef * IQR
  upper <- Q3 + coef * IQR
  sum(x < lower | x > upper, na.rm = TRUE) 
}

# Funkcija, kuri grąžina loginį vektorių (TRUE = ekstremali reikšmė)
is_extreme <- function(x, coef = 3) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - coef * IQR
  upper <- Q3 + coef * IQR
  (x < lower) | (x > upper)
}

# Pasirenkam kiekybinius kintamuosius
numeric_vars <- c("Vidutinės kuro sąnaudos (l/100km)",
                  "Kuro sąnaudos greitkelyje (l/100km)",
                  "Kuro sąnaudos mieste (l/100km)",
                  "Variklio tūris (l)",
                  "Cilindrų skaičius",
                  "CO2 emisijos (g/km)")

# Lentelė su išskirčių skaičiumi
outlier_summary <- data.frame(
  Outliers_1.5IQR = sapply(data[numeric_vars], check_outliers, coef = 1.5),
  Outliers_3IQR   = sapply(data[numeric_vars], check_outliers, coef = 3)
)

print(outlier_summary)

cat("Pradinė imtis:", nrow(data), "eilučių\n")

# Pašalinam ekstremalias reikšmes (pagal 3*IQR)
extreme_list <- lapply(data[numeric_vars], is_extreme, coef = 3)
rows_to_remove <- Reduce("|", extreme_list)   
data <- data[!rows_to_remove, ]

cat("Pašalinta išskirčių:", sum(rows_to_remove), "eilučių\n")
cat("Likusi imtis:", nrow(data), "eilučių\n")


```


```{r}
# Histograma su log10 transformuotomis CO2 emisijomis
hist(data$`CO2 emisijos (g/km)`,
     breaks = 40,
     probability = TRUE,
     main = "Automobilių CO2 emisijų pasiskirstymo histograma",
     xlab = "CO2 emisijos (g/km)",
     ylab = "Tankis",
     col = "lightblue",
     border = "black")

# Normalioji kreivė
x <- seq(min(data$`CO2 emisijos (g/km)`, na.rm=TRUE), max(data$`CO2 emisijos (g/km)`, na.rm=TRUE), length=100)
y <- dnorm(x, 
           mean=mean(data$`CO2 emisijos (g/km)`, na.rm=TRUE), 
           sd=sd(data$`CO2 emisijos (g/km)`, na.rm=TRUE))
lines(x, y, col="red", lwd=2)

legend(x = 5.75, y = 1.93,
       legend = c("CO2 emisijų pasiskirstymas", "Normalumo kreivė"),
       pch    = c(22, NA),              
       pt.cex = c(2, NA),               
       col    = c("black", "red"),      
       pt.bg  = c("lightblue", NA),     
       pt.lwd = c(1.5, NA),             
       lwd    = c(NA, 2),
       bty    = "n")

#QQ grafikas
library(car)

qqPlot(data$`CO2 emisijos (g/km)`, 
       dist = "norm",
       main = "QQ CO2 emisijų grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos CO2 emisijos (g/km)")

```
```{r}
# Statistinis Andersono-Darlingo testas
library(nortest)
ad.test(data$`CO2 emisijos (g/km)`)
```

```{r}
library(corrplot)
library(GGally)
library(ggplot2)

# 1. Paruošiami kiekybiniai kintamieji
numeric_vars <- data[, c("Variklio tūris (l)",
                          "Cilindrų skaičius",
                          "Kuro sąnaudos mieste (l/100km)",
                          "Kuro sąnaudos greitkelyje (l/100km)",
                          "Vidutinės kuro sąnaudos (l/100km)",
                          "CO2 emisijos (g/km)")]

colnames(numeric_vars) <- c("Variklio tūris (l)",
                            "Cilindrų\nskaičius",
                            "Kuro sąnaudos\nmieste (l/100km)",
                            "Kuro sąnaudos\ngreitkelyje (l/100km)",
                            "Vidutinės kuro\nsąnaudos (l/100km)",
                            "CO2 emisijos (g/km)")

# 2. Koreliacijų matrica
cor_matrix <- cor(numeric_vars, use = "complete.obs")

# 3. Heatmap su numbers metodu
corrplot(cor_matrix,
         method = "number",  
         type = "upper",      
         tl.col = "black",    
         tl.srt = 90,         
         number.cex = 0.8,    
         addCoef.col = "black") 

# 4. Sklaidos diagramų matrica
upper_fun <- function(data, mapping, ...) {
  ggplot(data, mapping) +
    geom_point(alpha = 0.5, color = "deepskyblue3") +         
    geom_smooth(method = "lm", se = FALSE, color = "red", lwd = 1) + 
    theme_minimal()
}

diag_fun <- function(data, mapping, ...) {
  var <- as_label(mapping$x)
  ggplot() +
    annotate("text", x = 0.5, y = 0.5, label = var, size = 4, fontface = "bold") +
    theme_void()
}

p <- suppressMessages(
  suppressWarnings(
    ggpairs(numeric_vars,
            upper = list(continuous = upper_fun),   
            lower = list(continuous = "blank"),     
            diag  = list(continuous = "blank"),    
            progress = FALSE) +
      ggtitle("Sklaidos diagramų matrica") +
      theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  )
)

# Išsaugom kaip PNG 
#ggsave(filename = "/Users/meliu/Desktop/scatter_matrix.png",
#       plot = p, width = 12, height = 12, dpi = 300)


```


```{r}
library(dplyr)
library(ggplot2)
library(colorspace)

dep_var <- "CO2 emisijos (g/km)"

# ===== Funkcija kategoriniams kintamiesiems =====
plot_box_rainbow <- function(data, var_name, title) {
  n_levels <- length(unique(data[[var_name]]))
  
  ggplot(data, aes(x = .data[[var_name]], 
                   y = `CO2 emisijos (g/km)`, 
                   fill = .data[[var_name]])) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = rainbow_hcl(n_levels, c = 60, l = 80)) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          legend.position = "none",
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5)
          )
}

#  Markės
p2 <- plot_box_rainbow(data, "Markė", "CO2 emisijos pagal 10 populiariausių markių") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p2)

#  Kėbulo tipas
p3 <- plot_box_rainbow(data, "Kėbulo tipas", "CO2 emisijos pagal kėbulo tipą")
print(p3)

#  Pavarų dėžės tipas
p4 <- plot_box_rainbow(data, "Pavarų dėžės tipas", "CO2 emisijos pagal pavarų dėžės tipą")
print(p4)

#  Kuro tipas
data <- data %>%
  filter(`Kuro tipas` != "Gamtinės dujos")

p5 <- plot_box_rainbow(data, "Kuro tipas", "CO2 emisijos pagal kuro tipą") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  
print(p5)


```


```{r}
library(dplyr)

# Funkcija dažnių lentelei 
freq_table_df <- function(data, var_name) {
  data %>%
    group_by(.data[[var_name]]) %>%
    summarise(Dažnis = n(), .groups = "drop") %>%
    arrange(desc(Dažnis))
}

# Markės
freq_marke <- freq_table_df(data, "Markė")

# Kėbulo tipas
freq_kebulas <- freq_table_df(data, "Kėbulo tipas")

# Pavarų dėžės tipas
freq_pavaros <- freq_table_df(data, "Pavarų dėžės tipas")

# Kuro tipas
freq_kuras <- freq_table_df(data, "Kuro tipas")

freq_marke
freq_kebulas
freq_pavaros
freq_kuras
```


```{r}
library(dplyr)
library(ggplot2)

# Funkcija vidurkio su dispersija grafiko sudarymui
mean_point_plot <- function(data, var_name, filter_values = NULL, color = "black", title = NULL) {
  df <- data
  if (!is.null(filter_values)) {
    df <- df %>% filter(.data[[var_name]] %in% filter_values)
  }
  
  summary_df <- df %>%
    group_by(.data[[var_name]]) %>%
    summarise(
      mean_CO2 = mean(`CO2 emisijos (g/km)`, na.rm = TRUE),
      sd_CO2   = sd(`CO2 emisijos (g/km)`, na.rm = TRUE),
      n        = n(),
      .groups  = "drop"
    ) %>%
    mutate(se = sd_CO2 / sqrt(n))
  
  ggplot(summary_df, aes(x = .data[[var_name]], y = mean_CO2)) +
    geom_point(size = 3, color = color) +
    geom_errorbar(aes(ymin = mean_CO2 - sd_CO2, ymax = mean_CO2 + sd_CO2),
                  width = 0.2, color = color) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5))
}

# Markės 
p_mean_marke <- mean_point_plot(data, "Markė",
                                color = "navy",
                                title = "Vidutinės CO2 emisijos pagal 10 populiariausių markių") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p_mean_marke)


# Kėbulo tipas 
p_mean_kebulas <- mean_point_plot(data, "Kėbulo tipas",
                                  color = "black",
                                  title = "Vidutinės CO2 emisijos pagal kėbulo tipą")
print(p_mean_kebulas)

# Pavarų dėžės tipas 
p_mean_pavare <- mean_point_plot(data, "Pavarų dėžės tipas",
                                 color = "darkred",
                                 title = "Vidutinės CO2 emisijos pagal pavarų dėžės tipą")
print(p_mean_pavare)

# Kuro tipas 
p_mean_kuras <- mean_point_plot(data, "Kuro tipas",
                                color = "darkgreen",
                                title = "Vidutinės CO2 emisijos pagal kuro tipą") 
print(p_mean_kuras)


```



```{r}
# 1. Pradinis modelis ir liekanų gavimas

library(dplyr)

# Pakeičiame kategorinius kintamuosius į faktorius
data$`Kuro tipas` <- as.factor(data$`Kuro tipas`)
data$`Pavarų dėžės tipas` <- as.factor(data$`Pavarų dėžės tipas`)
data$`Markė` <- as.factor(data$`Markė`)
data$`Kėbulo tipas` <- as.factor(data$`Kėbulo tipas`)

# Sukuriame pradinį modelį 
model1 <- lm(`CO2 emisijos (g/km)` ~ 
               `Vidutinės kuro sąnaudos (l/100km)` + 
               `Cilindrų skaičius` +
               `Kuro sąnaudos mieste (l/100km)` + 
               `Kuro sąnaudos greitkelyje (l/100km)` + 
               `Variklio tūris (l)` +
               `Pavarų dėžės tipas` +
               `Markė` +
               `Kuro tipas` +
               `Kėbulo tipas`, 
             data = data)

# Išsaugome liekanas ir diagnostinius rodiklius
data <- data %>%
  mutate(fitted = fitted(model1),
         resid = residuals(model1),
         rstd = rstandard(model1),
         rstud = rstudent(model1),
         hat = hatvalues(model1),
         cooks = cooks.distance(model1),
         obs = row_number())

```

```{r}
# 2. Prielaidų tikrinimas

#2.1. Bendrieji diagnostikos grafikai:
par(mfrow = c(2,2))
plot(model1)   
par(mfrow = c(1,1))

```
1. Residuals vs Fitted:
Liekanų sklaida rodo, kad modelio prielaida apie tiesinį ryšį daugmaž tenkinama, tačiau yra šiek tiek heteroskedastiškumo — didesni CO₂ rodikliai turi kiek didesnį liekanų išsibarstymą.
Tai gali būti dėl to, kad skirtingos markės ar kuro rūšys natūraliai turi skirtingus sklaidos lygius (pvz., sportiniai modeliai turi labiau kintamus CO₂ rodiklius).

2. QQ grafikas:
Liekanos daugmaž normalios, bet yra šiek tiek „uodegos“ dešinėje — t. y. kai kurie automobiliai turi labiau nei tikėtasi teigiamas liekanas (prognozuotas CO₂ < faktinis).
Tai natūralu, nes tam tikros markės (pvz., didesni, galingesni varikliai) gali būti sunkiau tiksliai aprašomos tiesiniu modeliu.

3. Scale-Location grafikas:
Kreivė nėra visiškai horizontali — matosi, kad didėjant prognozuotai CO₂ emisijai, liekanų išsibarstymas šiek tiek didėja.
Tai reiškia, kad heteroskedastiškumas šiek tiek padidėjęs. Kitaip tariant, modelis šiek tiek mažiau tiksliai prognozuoja didelius CO₂ rodiklius.
Tačiau bendrai tendencija nėra labai stipri — modelis vis dar pakankamai stabilus.

4.Cook's distance:
Modelyje yra keletas įtakingų stebėjimų — greičiausiai tai automobiliai su ypač didelėmis emisijomis (pvz., sportiniai arba hibridiniai su dideliu varikliu).
Juos verta patikrinti atskirai — ar jie realūs, ar galbūt klaidingi duomenys.
Tačiau šie taškai nekenkia modeliui drastiškai.

```{r}
#2.2. Liekanos pagal stebėjimų indeksą
par(mfrow = c(2,2))
plot(model1$residuals, pch = 16, col = "red")
plot(cooks.distance(model1), pch = 16, col = "blue")
plot(rstandard(model1), pch = 16, col = "blue")
plot(rstudent(model1), pch = 16, col = "blue")

```
Liekanos svyruoja aplink nulį be aiškios struktūros.
🔹 Nėra akivaizdžių grupavimų ar sekų, kas rodo, kad duomenys nėra priklausomi vienas nuo kito (t. y. nėra autokoreliacijos).

→ Išvada:
Modelio prielaida apie atsitiktines, nepriklausomas klaidas tenkinama.


```{r}
#2.3 Liekanų normalumas

par(mfrow=c(1,2))
qqnorm(residuals(model1), main="QQ plot")
qqline(residuals(model1))
hist(residuals(model1), main="Liekanų pasiskirstymas", breaks=30)
library(nortest)
ad.test(as.numeric(residuals(model1)))


```
Remiantis QQ diagrama ir liekanų histograma, galima teigti, kad liekanų pasiskirstymas yra artimas normaliam, tačiau pastebimi nedideli nukrypimai uodegose (ypač kairėje pusėje). Tai rodo, kad prielaida apie normaliai pasiskirsčiusias liekanas iš esmės tenkinama, nors pasiskirstymas nėra visiškai idealus.

```{r}
#2.4 Dispersijų lygumas (homoskedastiškumas)
library(lmtest)
library(sandwich)

bptest(model1)      # Breusch-Pagan
 
plot(model1$fitted, model1$resid); abline(h=0, lty=2)

#Korekcija:

coeftest(model1, vcov = vcovHC(model1, type = "HC3"))

```

```{r}
#3. Išskirtys
library(car)

outlierTest(model1)          
influenceIndexPlot(model1, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat"))  
```

```{r}
#3.1. Pašaliname išskirtis ir sukuriame naują modelį

# Studentizuotos liekanos
rstud <- rstudent(model1)

# Hat reikšmės
hatv <- hatvalues(model1)

# Cook's distance
cooks <- cooks.distance(model1)

# Įtartini taškai pagal bent vieną kriterijų
suspect <- which(abs(rstud) > 3 | hatv > 0.5 | cooks > (4/length(rstud)))

length(suspect)

# Sukuriame modelį be jų
data_clean <- data[-suspect, ]
model2 <- update(model1, data = data_clean)


```
Studentizuotos liekanos (rstudent) → rodo, ar stebėsena yra „neįprasta“ pagal savo klaidą (outlier pagal Y).

    Dažniausiai ribos: |rstudent| > 2 (arba > 3, jei daug duomenų).

Hat values (leverage) → rodo, kiek stebėsena turi įtakos savo prognozei (outlier pagal X).

    Didelės reikšmės reiškia, kad taškas yra „tolimas“ pagal nepriklausomus kintamuosius.

    Ribos: > 2*(p+1)/n arba > 0.5 (labai didelė), > 0.99 – ekstremali.

Cook’s distance → jungia abu kriterijus (Y ir X) ir parodo, kiek stebėsena keičia visą modelį.

    Ribos: > 4/n arba vizualiai išsiskiriantys taškai.


```{r}
#4. Multikolinearumas:
vif(model1)   
vif(model2)

```

```{r}
#4.1. Nauji modeliai (išimame kuro sąnaudas mieste ir greitkelyje bei cilindrų skaičių)

model1a <- lm(`CO2 emisijos (g/km)` ~ 
                `Vidutinės kuro sąnaudos (l/100km)` + 
                `Variklio tūris (l)`  + 
                `Pavarų dėžės tipas` +
                `Markė` +
                `Kuro tipas` +
                `Kėbulo tipas`,
              data = data)

vif(model1a)

model2a <- lm(`CO2 emisijos (g/km)` ~ 
                `Vidutinės kuro sąnaudos (l/100km)` + 
                `Variklio tūris (l)`  + 
                `Pavarų dėžės tipas` +
                `Markė` +
                `Kuro tipas` +
                `Kėbulo tipas`,
              data = data_clean)

vif(model2a)


```
    Kadangi faktoriai turi skirtingą laisvės laipsnių skaičių (Df = kategorijų skaičius – 1), GVIF reikšmės nėra tiesiogiai palyginamos tarp kintamųjų.

    Todėl daroma korekcija:

GVIF^(1/(2*Df))

    Ši transformacija „normalizuoja“ GVIF pagal kategorijų skaičių, kad galėtume palyginti jį su įprastais VIF slenksčiais (pvz., 4).


```{r}
# 4.2. Pažingsninis metodas:
library(MASS)

step_model1 <- stepAIC(model1, direction = c("both"))

step_model2 <- stepAIC(model2, direction = c("both"))

vif(step_model1)
vif(step_model2)

#Išvados: neišsprendžia multikolinearumo problemos.

```

Multikolinearumo problema buvo sprendžiama dviem būdais: rankiniu būdu ir taikant pažingsninę regresiją. Rankiniu būdu pašalinus kuro sąnaudas mieste, kuro sąnaudas greitkelyje ir cilindrų skaičių, VIF reikšmės sumažėjo iki < 4, todėl multikolinearumo problema buvo išspręsta. Tuo tarpu pažingsninė regresija, optimizuodama pagal AIC, paliko kintamuosius, kurių VIF išliko aukštas, todėl ši procedūra multikolinearumo problemos neišsprendė. Tolesnei analizei pasirinkti rankiniu būdu sudaryti modeliai, nes jie geriau atitiko prielaidas.

```{r}
#5. Prielaidų tikrinimas naujiems modeliams:

#5.1. Bendrieji diagnostikos grafikai:
par(mfrow = c(2,2))
plot(model1a)   
par(mfrow = c(1,1))

par(mfrow = c(2,2))
plot(model2a)   
par(mfrow = c(1,1))

```
```{r}
#5.2. Liekanos pagal stebėjimų indeksą
par(mfrow = c(2,2))
plot(model1a$residuals, pch = 16, col = "red")
plot(cooks.distance(model1a), pch = 16, col = "blue")
plot(rstandard(model1a), pch = 16, col = "blue")
plot(rstudent(model1a), pch = 16, col = "blue")

par(mfrow = c(2,2))
plot(model2a$residuals, pch = 16, col = "red")
plot(cooks.distance(model2a), pch = 16, col = "blue")
plot(rstandard(model2a), pch = 16, col = "blue")
plot(rstudent(model2a), pch = 16, col = "blue")
```
```{r}
#5.3 Liekanų normalumas

par(mfrow=c(1,2))
qqnorm(residuals(model1a), main="QQ plot")
qqline(residuals(model1a))
hist(residuals(model1a), main="Liekanų pasiskirstymas", breaks=30)
library(nortest)
ad.test(as.numeric(residuals(model1a)))

par(mfrow=c(1,2))
qqnorm(residuals(model2a), main="QQ plot")
qqline(residuals(model2a))
hist(residuals(model2a), main="Liekanų pasiskirstymas", breaks=30)
library(nortest)
ad.test(as.numeric(residuals(model2a)))

```

```{r}
#5.4 Dispersijų lygumas (homoskedastiškumas)
library(lmtest)
library(sandwich)

bptest(model1a)     
bptest(model2a)  


plot(fitted(model1a), resid(model1a),
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanos vs prognozuotos")
abline(h = 0, lty = 2, col = "red")

plot(fitted(model2a), resid(model2a),
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanos vs prognozuotos")
abline(h = 0, lty = 2, col = "red")


#Korekcija:

coeftest(model1a, vcov = vcovHC(model1a, type = "HC3"))
coeftest(model2a, vcov = vcovHC(model2a, type = "HC3"))
```
```{r}
#6. Išskirtys naujiems modeliams

outlierTest(model1a)          
influenceIndexPlot(model1a, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat")) 

outlierTest(model2a)          
influenceIndexPlot(model2a, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat")) 

```
```{r}
#7. Modelių tobulinimas

#7.1. Reikšmingų kovariančių atranka

summary(model1a)
summary(model2a)
```

```{r}
#7.2. Dalinė koreliacija

library(ppcor)

vars1 <- data[, c("CO2 emisijos (g/km)",
                       "Variklio tūris (l)",
                       "Vidutinės kuro sąnaudos (l/100km)")]

pcor(vars1)

vars2 <- data_clean[, c("CO2 emisijos (g/km)",
                       "Variklio tūris (l)",
                       "Vidutinės kuro sąnaudos (l/100km)")]

pcor(vars2)
```
```{r}
#7.3. Prognozuotos ir stebėtos reikšmės

plot(fitted(model1a), data$`CO2 emisijos (g/km)`,
     xlab="Prognozuotos reikšmės", ylab="Stebėtos reikšmės",
     main="Model1", pch=16, col="blue")
abline(0,1,col="red", lwd=2)

plot(fitted(model2a), data_clean$`CO2 emisijos (g/km)`,
     xlab="Prognozuotos reikšmės", ylab="Stebėtos reikšmės",
     main="Model2", pch=16, col="darkgreen")
abline(0,1,col="red", lwd=2)


```
Išvados: renkamės Model2 (be išskirčių), nes R^2 didesnis bei iš grafikų matosi, kad prognozuotos reikšmės labiau atitinka stebėtas.

```{r}
#8. Interpretacija: 
#kuris svarbiausias kintamasis, prognozavimas
```

































