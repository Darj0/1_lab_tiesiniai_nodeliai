---
title: "tm1lab"
author: "vilte"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}

#data <- read.csv("/Users/darjabaranova/Documents/VU/3_kursas/tiesiniai_metodai/CO2 Emissions_Canada.csv", header = TRUE)
data <- read.csv("C:/Users/meliu/Desktop/TM/CO2_Emissions_Canada.csv", header = TRUE)

data <- data[, - (ncol(data) - 1)]

data$logCO2 <- log(data$CO2.Emissions.g.km.)
names(data) <- c("Markė",
                 "Modelis",
                 "Kėbulo tipas",
                 "Variklio tūris (l)",
                 "Cilindrų skaičius",
                 "Pavarų dėžės tipas",
                 "Kuro tipas",
                 "Kuro sąnaudos mieste (l/100km)",
                 "Kuro sąnaudos greitkelyje (l/100km)",
                 "Vidutinės kuro sąnaudos (l/100km)",
                 "Vidutinės kuro sąnaudos (mpg)",
                 "CO2 emisijos (g/km)")


data$"Kėbulo tipas" <- with(data,
  ifelse(`Kėbulo tipas` %in% c("SUV - SMALL", "SUV - STANDARD"), "SUV",
  ifelse(`Kėbulo tipas` %in% c("MID-SIZE", "COMPACT", "SUBCOMPACT", 
                               "MINICOMPACT", "FULL-SIZE", "TWO-SEATER"),
         "Lengvieji automobiliai",
  ifelse(`Kėbulo tipas` %in% c("STATION WAGON - SMALL", "STATION WAGON - MID-SIZE"),
         "Universalai",
  ifelse(`Kėbulo tipas` %in% c("PICKUP TRUCK - SMALL", "PICKUP TRUCK - STANDARD"),
         "Pikapai",
  ifelse(`Kėbulo tipas` %in% c("MINIVAN", "VAN - PASSENGER", "VAN - CARGO"),
         "Vienatūriai",
  ifelse(`Kėbulo tipas` == "SPECIAL PURPOSE VEHICLE", 
         "Specialieji", NA)))))))


data$"Pavarų dėžės tipas" <- ifelse(grepl("^AM", data$`Pavarų dėžės tipas`), "Automatizuota mechaninė",
                             ifelse(grepl("^AS", data$`Pavarų dėžės tipas`), "Automatinė su rankiniu perjungimu",
                             ifelse(grepl("^AV", data$`Pavarų dėžės tipas`), "Bepakopė (CVT)",
                             ifelse(grepl("^A",  data$`Pavarų dėžės tipas`), "Automatinė",
                             ifelse(grepl("^M",  data$`Pavarų dėžės tipas`), "Mechaninė", NA)))))


data$"Kuro tipas" <- ifelse(data$`Kuro tipas` == "X", "Įprastas benzinas",
                     ifelse(data$`Kuro tipas` == "Z", "Aukštos kokybės benzinas",
                     ifelse(data$`Kuro tipas` == "D", "Dyzelinas",
                     ifelse(data$`Kuro tipas` == "E", "Etanolis (E85)",
                     ifelse(data$`Kuro tipas` == "N", "Gamtinės dujos", NA)))))

# Išrenkam Top 10 markių duomenis
top10 <- names(sort(table(data$Markė), decreasing = TRUE))[1:min(10, length(unique(data$Markė)))]

data <- subset(data, Markė %in% top10)

```

```{r}
# Histograma su log10 transformuotomis CO2 emisijomis
hist(data$`CO2 emisijos (g/km)`,
     breaks = 40,
     probability = TRUE,
     main = "Automobilių CO2 emisijų pasiskirstymo histograma",
     xlab = "CO2 emisijos (g/km)",
     ylab = "Tankis",
     col = "lightblue",
     border = "black")

# Normalioji kreivė
x <- seq(min(data$`CO2 emisijos (g/km)`, na.rm=TRUE), max(data$`CO2 emisijos (g/km)`, na.rm=TRUE), length=100)
y <- dnorm(x, 
           mean=mean(data$`CO2 emisijos (g/km)`, na.rm=TRUE), 
           sd=sd(data$`CO2 emisijos (g/km)`, na.rm=TRUE))
lines(x, y, col="red", lwd=2)

legend(x = 5.75, y = 1.9,
       legend = c("CO2 emisijų pasiskirstymas", "Normalumo kreivė"),
       pch    = c(22, NA),              
       pt.cex = c(2, NA),               
       col    = c("black", "red"),      
       pt.bg  = c("lightblue", NA),     
       pt.lwd = c(1.5, NA),             
       lwd    = c(NA, 2),
       bty    = "n")

#QQ grafikas
library(car)

qqPlot(data$`CO2 emisijos (g/km)`, 
       dist = "norm",
       main = "QQ CO2 emisijų grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos CO2 emisijos (g/km)")

```
```{r}
# Statistinis Andersono-Darlingo testas
library(nortest)
ad.test(data$`CO2 emisijos (g/km)`)
```

```{r}
library(corrplot)
library(GGally)
library(ggplot2)

# 1. Paruošiami kiekybiniai kintamieji
numeric_vars <- data[, c("Variklio tūris (l)",
                          "Cilindrų skaičius",
                          "Kuro sąnaudos mieste (l/100km)",
                          "Kuro sąnaudos greitkelyje (l/100km)",
                          "Vidutinės kuro sąnaudos (l/100km)",
                          "CO2 emisijos (g/km)")]

colnames(numeric_vars) <- c("Variklio tūris (l)",
                            "Cilindrų\nskaičius",
                            "Kuro sąnaudos\nmieste (l/100km)",
                            "Kuro sąnaudos\ngreitkelyje (l/100km)",
                            "Vidutinės kuro\nsąnaudos (l/100km)",
                            "CO2 emisijos (g/km)")

# 2. Koreliacijų matrica
cor_matrix <- cor(numeric_vars, use = "complete.obs")

# 3. Heatmap su numbers metodu
corrplot(cor_matrix,
         method = "number",  
         type = "upper",      
         tl.col = "black",    
         tl.srt = 90,         
         number.cex = 0.8,    
         addCoef.col = "black") 

# 4. Sklaidos diagramų matrica
upper_fun <- function(data, mapping, ...) {
  ggplot(data, mapping) +
    geom_point(alpha = 0.5, color = "deepskyblue3") +         
    geom_smooth(method = "lm", se = FALSE, color = "red", lwd = 1) + 
    theme_minimal()
}

diag_fun <- function(data, mapping, ...) {
  var <- as_label(mapping$x)
  ggplot() +
    annotate("text", x = 0.5, y = 0.5, label = var, size = 4, fontface = "bold") +
    theme_void()
}

p <- suppressMessages(
  suppressWarnings(
    ggpairs(numeric_vars,
            upper = list(continuous = upper_fun),   
            lower = list(continuous = "blank"),     
            diag  = list(continuous = "blank"),    
            progress = FALSE) +
      ggtitle("Sklaidos diagramų matrica") +
      theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  )
)

# Išsaugom kaip PNG 
#ggsave(filename = "/Users/meliu/Desktop/scatter_matrix.png",
#       plot = p, width = 12, height = 12, dpi = 300)


```


```{r}
library(dplyr)
library(ggplot2)
library(colorspace)

dep_var <- "CO2 emisijos (g/km)"

# ===== Funkcija kategoriniams kintamiesiems =====
plot_box_rainbow <- function(data, var_name, title) {
  n_levels <- length(unique(data[[var_name]]))
  
  ggplot(data, aes(x = .data[[var_name]], 
                   y = `CO2 emisijos (g/km)`, 
                   fill = .data[[var_name]])) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = rainbow_hcl(n_levels, c = 60, l = 80)) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          legend.position = "none",
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5)
          )
}

#  Markės
p2 <- plot_box_rainbow(data, "Markė", "CO2 emisijos pagal 10 populiariausių markių") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p2)

#  Kėbulo tipas
p3 <- plot_box_rainbow(data, "Kėbulo tipas", "CO2 emisijos pagal kėbulo tipą")
print(p3)

#  Pavarų dėžės tipas
p4 <- plot_box_rainbow(data, "Pavarų dėžės tipas", "CO2 emisijos pagal pavarų dėžės tipą")
print(p4)

#  Kuro tipas
data <- data %>%
  filter(`Kuro tipas` != "Gamtinės dujos")

p5 <- plot_box_rainbow(data, "Kuro tipas", "CO2 emisijos pagal kuro tipą") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  
print(p5)


```


```{r}
library(dplyr)

# Funkcija dažnių lentelei 
freq_table_df <- function(data, var_name) {
  data %>%
    group_by(.data[[var_name]]) %>%
    summarise(Dažnis = n(), .groups = "drop") %>%
    arrange(desc(Dažnis))
}

# Markės
freq_marke <- freq_table_df(data, "Markė")

# Kėbulo tipas
freq_kebulas <- freq_table_df(data, "Kėbulo tipas")

# Pavarų dėžės tipas
freq_pavaros <- freq_table_df(data, "Pavarų dėžės tipas")

# Kuro tipas
freq_kuras <- freq_table_df(data, "Kuro tipas")

freq_marke
freq_kebulas
freq_pavaros
freq_kuras
```


```{r}
library(dplyr)
library(ggplot2)

# Funkcija vidurkio su dispersija grafiko sudarymui
mean_point_plot <- function(data, var_name, filter_values = NULL, color = "black", title = NULL) {
  df <- data
  if (!is.null(filter_values)) {
    df <- df %>% filter(.data[[var_name]] %in% filter_values)
  }
  
  summary_df <- df %>%
    group_by(.data[[var_name]]) %>%
    summarise(
      mean_CO2 = mean(`CO2 emisijos (g/km)`, na.rm = TRUE),
      sd_CO2   = sd(`CO2 emisijos (g/km)`, na.rm = TRUE),
      n        = n(),
      .groups  = "drop"
    ) %>%
    mutate(se = sd_CO2 / sqrt(n))
  
  ggplot(summary_df, aes(x = .data[[var_name]], y = mean_CO2)) +
    geom_point(size = 3, color = color) +
    geom_errorbar(aes(ymin = mean_CO2 - sd_CO2, ymax = mean_CO2 + sd_CO2),
                  width = 0.2, color = color) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5))
}

# Markės 
p_mean_marke <- mean_point_plot(data, "Markė",
                                color = "navy",
                                title = "Vidutinės CO2 emisijos pagal 10 populiariausių markių") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p_mean_marke)


# Kėbulo tipas 
p_mean_kebulas <- mean_point_plot(data, "Kėbulo tipas",
                                  color = "black",
                                  title = "Vidutinės CO2 emisijos pagal kėbulo tipą")
print(p_mean_kebulas)

# Pavarų dėžės tipas 
p_mean_pavare <- mean_point_plot(data, "Pavarų dėžės tipas",
                                 color = "darkred",
                                 title = "Vidutinės CO2 emisijos pagal pavarų dėžės tipą")
print(p_mean_pavare)

# Kuro tipas 
p_mean_kuras <- mean_point_plot(data, "Kuro tipas",
                                color = "darkgreen",
                                title = "Vidutinės CO2 emisijos pagal kuro tipą") 
print(p_mean_kuras)


```



```{r}
# ================================
# 1. PRADINIS MODELIS
# ================================
library(dplyr)

# Sukuriame pradinį modelį su svarbiausiais kiekybiniais kintamaisiais
model1 <- lm(`CO2 emisijos (g/km)` ~ 
               `Variklio tūris (l)` + 
               `Cilindrų skaičius` + 
               `Vidutinės kuro sąnaudos (l/100km)`, 
             data = data)

```

```{r}
# ================================
# 2. MULTIKOLINEARUMO PATIKRINIMAS
# ================================
library(car)
vif(model1)

```

```{r}
#Išemame cilindrų skaičiaus kintamąjį, kad VIF būtų mažesnis už 4, ir sukuriame naują modelį.
model2 <- lm(`CO2 emisijos (g/km)` ~ 
               `Vidutinės kuro sąnaudos (l/100km)` + 
               `Variklio tūris (l)`, 
             data = data)
vif(model2)

```

```{r}
# ================================
# 3. IŠSKIRČIŲ PATIKRINIMAS
# ================================

library(car)

# 1. Išskirčių testas (Bonferroni p-value)
outlierTest(model2)

# 2. Vizualus įtakos ir svertinių taškų patikrinimas
influenceIndexPlot(model2, 
                   id=list(method="y", n=3), 
                   vars=c("Cook", "Studentized", "hat"))


# IŠSKIRČIŲ PAŠALINIMAS IR ŠVARAUS MODELIO KŪRIMAS

# Surandam stebėjimus, kurie daro didelę įtaką ( Cook's distance > 4/n)
n <- nrow(model2$model)
influence <- cooks.distance(model2)
influential_points <- which(influence > (4/n))

# Patikrinam, kurie tai stebėjimai
influential_points

# Sukuriam naują duomenų rinkinį be išskirčių
data_clean <- model2$model[-influential_points, ]

# Sukuriam "švaresnį" modelį
model_clean <- update(model2, data = data_clean)

# ŠVARAUS MODELIO PATIKRINIMAS

# Palyginimas su senu modeliu
library(broom)

# Ištraukiam pagrindinę statistiką iš abiejų modelių
compare_models <- data.frame(
  Model = c("Senas modelis", "Išvalytas modelis"),
  R2 = c(summary(model2)$r.squared,
         summary(model_clean)$r.squared),
  Adj_R2 = c(summary(model2)$adj.r.squared,
             summary(model_clean)$adj.r.squared),
  AIC = c(AIC(model2),
          AIC(model_clean)),
  BIC = c(BIC(model2),
          BIC(model_clean)),
  F_stat = c(summary(model2)$fstatistic[1],
             summary(model_clean)$fstatistic[1]),
  p_value_F = c(pf(summary(model2)$fstatistic[1],
                   summary(model2)$fstatistic[2],
                   summary(model2)$fstatistic[3],
                   lower.tail=FALSE),
                pf(summary(model_clean)$fstatistic[1],
                   summary(model_clean)$fstatistic[2],
                   summary(model_clean)$fstatistic[3],
                   lower.tail=FALSE))
)

# Atvaizduojam kaip gražią lentelę
print(compare_models, row.names = FALSE)

#Multikolinearumo patikrinimas modeliui be išskirčių:
vif(model_clean)

```
1. StudRes (rstudent)

Tai studentizuotos liekanos, kurios parodo, kiek kiekvienas taškas nutolęs nuo modelio prognozės.
Taisyklė:
Jei |rstudent| > 3, tai laikoma išskirtimi (outlier).

2. Hat (leverage)

Parodo, kiek stebėjimas turi įtakos modelio koeficientams.
Taisyklė:
Ribinė reikšmė ≈ 2(k+1)/n, kur:

k – nepriklausomų kintamųjų skaičius,

n – stebėjimų skaičius.

Jei Hat > ribinės reikšmės → taškas turi didelę įtaką modelio formai.

3. Cook’s Distance (CookD)

Matuoja, kiek stebėjimo pašalinimas pakeistų visą modelį.
Taisyklė:

Jei CookD > 4/n, tai laikoma įtakingu tašku (influential point),
n - stebėjimų sk.


```{r}
# ================================
# 4. MODELIO PRIELAIDŲ TIKRINIMAS
# ================================
par(mfrow = c(2, 2))
plot(model_clean)
par(mfrow = c(1, 1))

```
1. Liekanos prieš prognozuotas reikšmes (Residuals vs Fitted)

X ašis: Pritaikytos (numatytos) reikšmės – tai modelio prognozuotos CO₂ emisijos.
Y ašis: Liekanos – skirtumas tarp stebėtų ir modelio prognozuotų reikšmių (t. y. klaidos).

Ką rodo:
Ar modelis atitinka tiesiškumo ir homoskedastiškumo prielaidą.
Jei taškai atsitiktinai išsidėstę aplink horizontalią liniją (be aiškios formos), prielaida tenkinama.
Jei matosi kreivės forma ar „piltuvėlis“, reiškia netolygus sklaidos plotis (heteroskedastiškumas).

2. Q-Q grafikas

X ašis: Teoriniai kvantiliai (jei liekanos būtų tobulai normaliai pasiskirsčiusios).
Y ašis: Stebėtos liekanos (modelio likučiai).

Ką rodo:
Ar liekanos pasiskirsčiusios normaliai.
Jei taškai išsidėstę palei įstrižainę – viskas gerai.
Dideli nukrypimai nuo linijos rodo nnormalumą (pvz., išskirtis arba asimetrija).

3. Skalės–vietos grafikas (Scale–Location)

X ašis: Pritaikytos reikšmės (prognozuotos CO₂ emisijos).
Y ašis: Šakninis standartizuotų liekanų dydis (√|stand. liekanos|).

Ką rodo:
Patikrina homoskedastiškumo prielaidą dar kartą.
Jei raudona linija beveik horizontali → gerai.
Jei ji kyla ar leidžiasi – liekanų sklaida kinta priklausomai nuo prognozuotų reikšmių, t. y. heteroskedastiškumas.

4. Liekanų įtakos (Residuals vs Leverage) grafikas

X ašis: Leverage (svertinis taškų atstumas nuo vidurkio – kiek įtakos turi taškas modelio koeficientams).
Y ašis: Standartizuotos liekanos.

Ką rodo:
Įtakingus arba išsiskiriančius taškus.
Apskritimai su didelėmis Cook's distance reikšmėmis rodo, kad tie taškai gali turėti didelę įtaką modeliui.
Jei keli taškai yra toli nuo kitų, juos verta patikrinti.

```{r}
# 1. Liekanų normalumo testas
library(nortest)
ad_result <- ad.test(residuals(model_clean))
print(ad_result)

if(ad_result$p.value < 0.05) {
  cat("Liekanos nenormaliosios (p =", ad_result$p.value, ").\n")
} else {
  cat("Liekanos normaliosios (p =", ad_result$p.value, ").\n")
}

# 2. Liekanų sklaidos diagrama
plot(fitted(model_clean), residuals(model_clean),
     pch = 16, col = "steelblue",
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanų sklaidos diagrama")
abline(h = 0, col = "red", lwd = 2)

# 3. Homoskedastiškumo testas
library(lmtest)
bp_result <- bptest(model_clean)
print(bp_result)

if(bp_result$p.value < 0.05) {
  cat("Heteroskedastiškumas nustatytas (p =", bp_result$p.value, ").\n")
} else {
  cat("Homoskedastiškumas (p =", bp_result$p.value, ").\n")
}

# 4. Korekcija heteroskedastiškumui su HC3
library(sandwich)

hc3_result <- coeftest(model_clean, vcov = vcovHC(model_clean, type = "HC3"))
print(hc3_result)


```

```{r}
# ================================
# 5. ŽINGSNINĖ REGRESIJA
# ================================

# Atliekame žingsninę regresiją pagal AIC kriterijų
library(MASS)
model_step <- stepAIC(model_clean, direction = "both")

summary(model_step)

```

```{r}
# ================================
# 6. HIPOTEZIŲ TIKRINIMAS
# ================================
# H0: β1 = β2 = ... = βm = 0
anova(model_clean)

# H_j: βj = 0 (t-test)
summary(model_clean)

#Parametrų pasikliovimo intervalai:
confint(model_clean)

```



```{r}
# ================================
# 7. PROGNOZAVIMAS
# ================================
new_data <- data.frame(
  `Vidutinės kuro sąnaudos (l/100km)` = c(7.5, 9.0),
  `Variklio tūris (l)` = c(1.8, 2.0)
)
names(new_data) <- names(model_clean$model)[-1]  

predictions <- predict(model_clean, newdata = new_data, interval = "prediction")
print(predictions)


```

```{r}
Rodikliai <- data_clean  

Rodikliai <- within(Rodikliai, {
  fitted.model_clean <- fitted(model_clean)
  residuals.model_clean <- residuals(model_clean)
  rstudent.model_clean <- rstudent(model_clean)
  hatvalues.model_clean <- hatvalues(model_clean)
  cooks.distance.model_clean <- cooks.distance(model_clean)
  obsNumber <- 1:nrow(Rodikliai)
})

Rodikliai <- Rodikliai[, c("Variklio tūris (l)", 
                            "Vidutinės kuro sąnaudos (l/100km)",
                            "fitted.model_clean", 
                            "residuals.model_clean", 
                            "rstudent.model_clean", 
                            "hatvalues.model_clean", 
                            "cooks.distance.model_clean", 
                            "obsNumber")]

head(Rodikliai)


```

```{r}
library(ggplot2)

ggplot(data_clean, aes(x = fitted(model_clean), y = `CO2 emisijos (g/km)`)) +
  geom_point(color = "blue", alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  labs(
    x = "Prognozuotos reikšmės",
    y = "Stebėtos reikšmės",
    title = "Prognozuotų ir stebėtų CO2 emisijų sklaidos diagrama"
  ) +
  theme_minimal()

```


Kategoriniai kintamieji
```{r}
#Konvertuojame į faktorius:
data$Kebulo_tipas <- as.factor(data$`Kėbulo tipas`)
data$Pavaru_dezes_tipas <- as.factor(data$`Pavarų dėžės tipas`)
data$Modelis <- as.factor(data$`Modelis`)

str(data)
```




