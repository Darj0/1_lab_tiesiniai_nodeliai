
---
title: "tm1lab"
author: "vilte"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
library(dplyr)

#data <- read.csv("CO2 Emissions_Canada.csv", header = TRUE)
data <- read.csv("CO2_Emissions_Canada.csv", header = TRUE)

data <- data[, - (ncol(data) - 1)]

names(data) <- c("MarkÄ—",
                 "Modelis",
                 "KÄ—bulo tipas",
                 "Variklio tÅ«ris (l)",
                 "CilindrÅ³ skaiÄius",
                 "PavarÅ³ dÄ—Å¾Ä—s tipas",
                 "Kuro tipas",
                 "Kuro sÄ…naudos mieste (l/100km)",
                 "Kuro sÄ…naudos greitkelyje (l/100km)",
                 "VidutinÄ—s kuro sÄ…naudos (l/100km)",
                 "CO2 emisijos (g/km)")


data$"KÄ—bulo tipas" <- with(data,
  ifelse(`KÄ—bulo tipas` %in% c("SUV - SMALL", "SUV - STANDARD"), "SUV",
  ifelse(`KÄ—bulo tipas` %in% c("MID-SIZE", "COMPACT", "SUBCOMPACT", 
                               "MINICOMPACT", "FULL-SIZE", "TWO-SEATER"),
         "Lengvieji automobiliai",
  ifelse(`KÄ—bulo tipas` %in% c("STATION WAGON - SMALL", "STATION WAGON - MID-SIZE"),
         "Universalai",
  ifelse(`KÄ—bulo tipas` %in% c("PICKUP TRUCK - SMALL", "PICKUP TRUCK - STANDARD"),
         "Pikapai",
  ifelse(`KÄ—bulo tipas` %in% c("MINIVAN", "VAN - PASSENGER", "VAN - CARGO"),
         "VienatÅ«riai",
  ifelse(`KÄ—bulo tipas` == "SPECIAL PURPOSE VEHICLE", 
         "Specialieji", NA)))))))


data$"PavarÅ³ dÄ—Å¾Ä—s tipas" <- ifelse(grepl("^AM", data$`PavarÅ³ dÄ—Å¾Ä—s tipas`), "Automatizuota mechaninÄ—",
                             ifelse(grepl("^AS", data$`PavarÅ³ dÄ—Å¾Ä—s tipas`), "AutomatinÄ— su rankiniu perjungimu",
                             ifelse(grepl("^AV", data$`PavarÅ³ dÄ—Å¾Ä—s tipas`), "BepakopÄ— (CVT)",
                             ifelse(grepl("^A",  data$`PavarÅ³ dÄ—Å¾Ä—s tipas`), "AutomatinÄ—",
                             ifelse(grepl("^M",  data$`PavarÅ³ dÄ—Å¾Ä—s tipas`), "MechaninÄ—", NA)))))


data$"Kuro tipas" <- ifelse(data$`Kuro tipas` == "X", "Ä®prastas benzinas",
                     ifelse(data$`Kuro tipas` == "Z", "AukÅ¡tos kokybÄ—s benzinas",
                     ifelse(data$`Kuro tipas` == "D", "Dyzelinas",
                     ifelse(data$`Kuro tipas` == "E", "Etanolis (E85)",
                     ifelse(data$`Kuro tipas` == "N", "GamtinÄ—s dujos", NA)))))


data <- data %>%
  filter(`Variklio tÅ«ris (l)` == 2.0)%>%
  droplevels()



```

```{r}
# DuomenÅ³ iÅ¡valymas:

# Patikrinam, kiek yra NA reikÅ¡miÅ³
colSums(is.na(data))

# Funkcija, kuri patikrina iÅ¡skirtis pagal IQR
check_outliers <- function(x, coef = 1.5) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - coef * IQR
  upper <- Q3 + coef * IQR
  sum(x < lower | x > upper, na.rm = TRUE) 
}

# Funkcija, kuri grÄ…Å¾ina loginÄ¯ vektoriÅ³ (TRUE = ekstremali reikÅ¡mÄ—)
is_extreme <- function(x, coef = 3) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - coef * IQR
  upper <- Q3 + coef * IQR
  (x < lower) | (x > upper)
}

# Pasirenkam kiekybinius kintamuosius
numeric_vars <- c("VidutinÄ—s kuro sÄ…naudos (l/100km)",
                  "Kuro sÄ…naudos greitkelyje (l/100km)",
                  "Kuro sÄ…naudos mieste (l/100km)",
                  "CilindrÅ³ skaiÄius",
                  "CO2 emisijos (g/km)")

# LentelÄ— su iÅ¡skirÄiÅ³ skaiÄiumi
outlier_summary <- data.frame(
  Outliers_1.5IQR = sapply(data[numeric_vars], check_outliers, coef = 1.5),
  Outliers_3IQR   = sapply(data[numeric_vars], check_outliers, coef = 3)
)

print(outlier_summary)

cat("PradinÄ— imtis:", nrow(data), "eiluÄiÅ³\n")

# PaÅ¡alinam ekstremalias reikÅ¡mes (pagal 3*IQR)
extreme_list <- lapply(data[numeric_vars], is_extreme, coef = 3)
rows_to_remove <- Reduce("|", extreme_list)   
data <- data[!rows_to_remove, ]

cat("PaÅ¡alinta iÅ¡skirÄiÅ³:", sum(rows_to_remove), "eiluÄiÅ³\n")
cat("Likusi imtis:", nrow(data), "eiluÄiÅ³\n")


```


```{r}
# Histograma su CO2 emisijomis
hist(data$`CO2 emisijos (g/km)`,
     breaks = 40,
     probability = TRUE,
     main = "AutomobiliÅ³ CO2 emisijÅ³ pasiskirstymo histograma",
     xlab = "CO2 emisijos (g/km)",
     ylab = "Tankis",
     col = "lightblue",
     border = "black")

# Normalioji kreivÄ—
x <- seq(min(data$`CO2 emisijos (g/km)`, na.rm=TRUE), max(data$`CO2 emisijos (g/km)`, na.rm=TRUE), length=100)
y <- dnorm(x, 
           mean=mean(data$`CO2 emisijos (g/km)`, na.rm=TRUE), 
           sd=sd(data$`CO2 emisijos (g/km)`, na.rm=TRUE))
lines(x, y, col="red", lwd=2)

legend(x = 5.75, y = 1.93,
       legend = c("CO2 emisijÅ³ pasiskirstymas", "Normalumo kreivÄ—"),
       pch    = c(22, NA),              
       pt.cex = c(2, NA),               
       col    = c("black", "red"),      
       pt.bg  = c("lightblue", NA),     
       pt.lwd = c(1.5, NA),             
       lwd    = c(NA, 2),
       bty    = "n")

#QQ grafikas
library(car)

qqPlot(data$`CO2 emisijos (g/km)`, 
       dist = "norm",
       main = "QQ CO2 emisijÅ³ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "StebÄ—tos CO2 emisijos (g/km)")

```
```{r}
# Statistinis Andersono-Darlingo testas
library(nortest)
ad.test(data$`CO2 emisijos (g/km)`)
```

```{r}
library(corrplot)
library(GGally)
library(ggplot2)

# 1. ParuoÅ¡iami kiekybiniai kintamieji
numeric_vars <- data[, c("Kuro sÄ…naudos mieste (l/100km)",
                          "Kuro sÄ…naudos greitkelyje (l/100km)",
                          "VidutinÄ—s kuro sÄ…naudos (l/100km)",
                          "CO2 emisijos (g/km)")]

colnames(numeric_vars) <- c("Kuro sÄ…naudos\nmieste (l/100km)",
                            "Kuro sÄ…naudos\ngreitkelyje (l/100km)",
                            "VidutinÄ—s kuro\nsÄ…naudos (l/100km)",
                            "CO2 emisijos (g/km)")

# 2. KoreliacijÅ³ matrica
cor_matrix <- cor(numeric_vars, use = "complete.obs")

# 3. Heatmap su numbers metodu
corrplot(cor_matrix,
         method = "number",  
         type = "upper",      
         tl.col = "black",    
         tl.srt = 90,         
         number.cex = 0.8,    
         addCoef.col = "black") 

# 4. Sklaidos diagramÅ³ matrica
upper_fun <- function(data, mapping, ...) {
  ggplot(data, mapping) +
    geom_point(alpha = 0.5, color = "deepskyblue3") +         
    geom_smooth(method = "lm", se = FALSE, color = "red", lwd = 1) + 
    theme_minimal()
}

diag_fun <- function(data, mapping, ...) {
  var <- as_label(mapping$x)
  ggplot() +
    annotate("text", x = 0.5, y = 0.5, label = var, size = 4, fontface = "bold") +
    theme_void()
}

p <- suppressMessages(
  suppressWarnings(
    ggpairs(numeric_vars,
            upper = list(continuous = upper_fun),   
            lower = list(continuous = "blank"),     
            diag  = list(continuous = "blank"),    
            progress = FALSE) +
      ggtitle("Sklaidos diagramÅ³ matrica") +
      theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  )
)

# IÅ¡saugom kaip PNG 
ggsave(filename = "scatter.png",
plot = p, width = 12, height = 12, dpi = 300)


```


```{r}
library(dplyr)
library(ggplot2)
library(colorspace)

dep_var <- "CO2 emisijos (g/km)"

# ===== Funkcija kategoriniams kintamiesiems =====
plot_box_rainbow <- function(data, var_name, title) {
  n_levels <- length(unique(data[[var_name]]))
  
  ggplot(data, aes(x = .data[[var_name]], 
                   y = `CO2 emisijos (g/km)`, 
                   fill = .data[[var_name]])) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = rainbow_hcl(n_levels, c = 60, l = 80)) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          legend.position = "none",
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5)
          )
}

#  MarkÄ—s
p2 <- plot_box_rainbow(data, "MarkÄ—", "CO2 emisijos pagal markes") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p2)

#  KÄ—bulo tipas
p3 <- plot_box_rainbow(data, "KÄ—bulo tipas", "CO2 emisijos pagal kÄ—bulo tipÄ…")
print(p3)

#  PavarÅ³ dÄ—Å¾Ä—s tipas
p4 <- plot_box_rainbow(data, "PavarÅ³ dÄ—Å¾Ä—s tipas", "CO2 emisijos pagal pavarÅ³ dÄ—Å¾Ä—s tipÄ…")
print(p4)

#  Kuro tipas
data <- data %>%
  filter(`Kuro tipas` != "GamtinÄ—s dujos")

p5 <- plot_box_rainbow(data, "Kuro tipas", "CO2 emisijos pagal kuro tipÄ…") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  
print(p5)


```


```{r}
library(dplyr)

# Funkcija daÅ¾niÅ³ lentelei 
freq_table_df <- function(data, var_name) {
  data %>%
    group_by(.data[[var_name]]) %>%
    summarise(DaÅ¾nis = n(), .groups = "drop") %>%
    arrange(desc(DaÅ¾nis))
}

# MarkÄ—s
freq_marke <- freq_table_df(data, "MarkÄ—")

# KÄ—bulo tipas
freq_kebulas <- freq_table_df(data, "KÄ—bulo tipas")

# PavarÅ³ dÄ—Å¾Ä—s tipas
freq_pavaros <- freq_table_df(data, "PavarÅ³ dÄ—Å¾Ä—s tipas")

# Kuro tipas
freq_kuras <- freq_table_df(data, "Kuro tipas")

freq_marke
freq_kebulas
freq_pavaros
freq_kuras
```


```{r}
library(dplyr)
library(ggplot2)

# Funkcija vidurkio su dispersija grafiko sudarymui
mean_point_plot <- function(data, var_name, filter_values = NULL, color = "black", title = NULL) {
  df <- data
  if (!is.null(filter_values)) {
    df <- df %>% filter(.data[[var_name]] %in% filter_values)
  }
  
  summary_df <- df %>%
    group_by(.data[[var_name]]) %>%
    summarise(
      mean_CO2 = mean(`CO2 emisijos (g/km)`, na.rm = TRUE),
      sd_CO2   = sd(`CO2 emisijos (g/km)`, na.rm = TRUE),
      n        = n(),
      .groups  = "drop"
    ) %>%
    mutate(se = sd_CO2 / sqrt(n))
  
  ggplot(summary_df, aes(x = .data[[var_name]], y = mean_CO2)) +
    geom_point(size = 3, color = color) +
    geom_errorbar(aes(ymin = mean_CO2 - sd_CO2, ymax = mean_CO2 + sd_CO2),
                  width = 0.2, color = color) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5))
}

# MarkÄ—s 
p_mean_marke <- mean_point_plot(data, "MarkÄ—",
                                color = "navy",
                                title = "VidutinÄ—s CO2 emisijos pagal markes") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p_mean_marke)


# KÄ—bulo tipas 
p_mean_kebulas <- mean_point_plot(data, "KÄ—bulo tipas",
                                  color = "black",
                                  title = "VidutinÄ—s CO2 emisijos pagal kÄ—bulo tipÄ…")
print(p_mean_kebulas)

# PavarÅ³ dÄ—Å¾Ä—s tipas 
p_mean_pavare <- mean_point_plot(data, "PavarÅ³ dÄ—Å¾Ä—s tipas",
                                 color = "darkred",
                                 title = "VidutinÄ—s CO2 emisijos pagal pavarÅ³ dÄ—Å¾Ä—s tipÄ…")
print(p_mean_pavare)

# Kuro tipas 
p_mean_kuras <- mean_point_plot(data, "Kuro tipas",
                                color = "darkgreen",
                                title = "VidutinÄ—s CO2 emisijos pagal kuro tipÄ…") 
print(p_mean_kuras)


```

```{r}
set.seed(123) 
data <- data[sample(nrow(data)), ]

train_index <- sample(1:nrow(data), 0.8 * nrow(data))

train_data <- data[train_index, ]
test_data <- data[-train_index, ]

cat("EiluÄiÅ³ skaiÄius pradiniuose duomenyse:", nrow(data), "\n")
cat("EiluÄiÅ³ skaiÄius treniravimo aibÄ—je:", nrow(train_data), "\n")
cat("EiluÄiÅ³ skaiÄius testavimo aibÄ—je:", nrow(test_data), "\n")

```



```{r}
# 1. Pradinis modelis ir liekanÅ³ gavimas
# PakeiÄiame kategorinius kintamuosius Ä¯ faktorius
train_data$`PavarÅ³ dÄ—Å¾Ä—s tipas` <- as.factor(train_data$`PavarÅ³ dÄ—Å¾Ä—s tipas`)
train_data$`Kuro tipas`         <- as.factor(train_data$`Kuro tipas`)
train_data$`MarkÄ—`              <- as.factor(train_data$`MarkÄ—`)
train_data$`KÄ—bulo tipas`       <- as.factor(train_data$`KÄ—bulo tipas`)


# Sukuriame pradinÄ¯ modelÄ¯ 
model1 <- lm(`CO2 emisijos (g/km)` ~ 
               `VidutinÄ—s kuro sÄ…naudos (l/100km)` + 
               `Kuro sÄ…naudos mieste (l/100km)` + 
               `Kuro sÄ…naudos greitkelyje (l/100km)` + 
               `PavarÅ³ dÄ—Å¾Ä—s tipas` +
               `Kuro tipas` +
               `MarkÄ—`+
               `KÄ—bulo tipas`,
             data = train_data)

# IÅ¡saugome liekanas ir diagnostinius rodiklius
train_data <- train_data %>%
  mutate(fitted = fitted(model1),
         resid = residuals(model1),
         rstd = rstandard(model1),
         rstud = rstudent(model1),
         hat = hatvalues(model1),
         cooks = cooks.distance(model1),
         obs = row_number())

```

```{r}
# 2. PrielaidÅ³ tikrinimas
par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos vs prognozuotos reikÅ¡mÄ—s
plot(fitted(model1), resid(model1),
     pch = 21, col = "deepskyblue3",
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos reikÅ¡mÄ—s")
abline(h = 0, lty = 2, col = "red")

# 2. QQ grafikas
qqnorm(resid(model1), pch = 21, col = "deepskyblue3",
       main = "LiekanÅ³ QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "StebÄ—tos liekanos")
qqline(resid(model1), col = "red", lwd = 2)

# 3. Scale-Location (standartizuotos liekanos vs prognozuotos)
plot(fitted(model1), sqrt(abs(rstandard(model1))),
     pch = 21, col = "deepskyblue3",
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "Standartizuotos liekanos",
     main = "Scale-Location grafikas")
lines(lowess(fitted(model1), sqrt(abs(rstandard(model1)))),
      col = "red", lwd = 2)

# 4. Cook's distance
plot(cooks.distance(model1), type = "h",
     col = "deepskyblue3", lwd = 2,
     xlab = "StebÄ—jimo indeksas",
     ylab = "Cook's atstumas",
     main = "Ä®takingi taÅ¡kai (Cook's distance)")
abline(h = 4/length(resid(model1)), col = "red", lty = 2)

par(mfrow = c(1,1))


```
1. Residuals vs Fitted:
LiekanÅ³ sklaida rodo, kad modelio prielaida apie tiesinÄ¯ ryÅ¡Ä¯ daugmaÅ¾ tenkinama, taÄiau yra Å¡iek tiek heteroskedastiÅ¡kumo â€” didesni COâ‚‚ rodikliai turi kiek didesnÄ¯ liekanÅ³ iÅ¡sibarstymÄ….
Tai gali bÅ«ti dÄ—l to, kad skirtingos markÄ—s ar kuro rÅ«Å¡ys natÅ«raliai turi skirtingus sklaidos lygius (pvz., sportiniai modeliai turi labiau kintamus COâ‚‚ rodiklius).

2. QQ grafikas:
Liekanos daugmaÅ¾ normalios, bet yra Å¡iek tiek â€uodegosâ€œ deÅ¡inÄ—je â€” t. y. kai kurie automobiliai turi labiau nei tikÄ—tasi teigiamas liekanas (prognozuotas COâ‚‚ < faktinis).
Tai natÅ«ralu, nes tam tikros markÄ—s (pvz., didesni, galingesni varikliai) gali bÅ«ti sunkiau tiksliai apraÅ¡omos tiesiniu modeliu.

3. Scale-Location grafikas:
KreivÄ— nÄ—ra visiÅ¡kai horizontali â€” matosi, kad didÄ—jant prognozuotai COâ‚‚ emisijai, liekanÅ³ iÅ¡sibarstymas Å¡iek tiek didÄ—ja.
Tai reiÅ¡kia, kad heteroskedastiÅ¡kumas Å¡iek tiek padidÄ—jÄ™s. Kitaip tariant, modelis Å¡iek tiek maÅ¾iau tiksliai prognozuoja didelius COâ‚‚ rodiklius.
TaÄiau bendrai tendencija nÄ—ra labai stipri â€” modelis vis dar pakankamai stabilus.

4.Cook's distance:
Modelyje yra keletas Ä¯takingÅ³ stebÄ—jimÅ³ â€” greiÄiausiai tai automobiliai su ypaÄ didelÄ—mis emisijomis (pvz., sportiniai arba hibridiniai su dideliu varikliu).
Juos verta patikrinti atskirai â€” ar jie realÅ«s, ar galbÅ«t klaidingi duomenys.
TaÄiau Å¡ie taÅ¡kai nekenkia modeliui drastiÅ¡kai.

```{r}
#2.2. Liekanos pagal stebÄ—jimÅ³ indeksÄ…
par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos
plot(model1$residuals, 
     pch = 21, col = "red",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Liekanos",
     main = "Liekanos pagal stebÄ—jimus")
abline(h = 0, col = "black", lty = 2, lwd = 2)

# 2. Cook's atstumas
plot(cooks.distance(model1), 
     pch = 21, col = "deepskyblue3",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Cook's atstumas",
     main = "Ä®takingi taÅ¡kai (Cook's distance)")
abline(h = 4/length(resid(model1)), col = "black", lty = 2, lwd = 2)

# 3. Standartizuotos liekanos
plot(rstandard(model1), 
     pch = 21, col = "deepskyblue3",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Standartizuotos liekanos",
     main = "Standartizuotos liekanos")
abline(h = c(-2,0,2), col = c("black","black","black"), lty = c(2,2,2))

# 4. Studentizuotos liekanos
plot(rstudent(model1), 
     pch = 21, col = "deepskyblue3",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Studentizuotos liekanos",
     main = "Studentizuotos liekanos")
abline(h = c(-3,0,3), col = c("black","black","black"), lty = c(2,2,2))

par(mfrow = c(1,1))


```
Liekanos svyruoja aplink nulÄ¯ be aiÅ¡kios struktÅ«ros.
ğŸ”¹ NÄ—ra akivaizdÅ¾iÅ³ grupavimÅ³ ar sekÅ³, kas rodo, kad duomenys nÄ—ra priklausomi vienas nuo kito (t. y. nÄ—ra autokoreliacijos).

â†’ IÅ¡vada:
Modelio prielaida apie atsitiktines, nepriklausomas klaidas tenkinama.


```{r}
#2.3 LiekanÅ³ normalumas
par(mfrow = c(1,2), mar = c(4.5,4.5,3,1))

par(mfrow = c(1,2), mar = c(4.5,4.5,3,1))

# QQ grafikas
qqnorm(residuals(model1),
       pch = 21, col = "deepskyblue3",
       main = "LiekanÅ³ QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "StebÄ—tos liekanos")
qqline(residuals(model1), col = "red", lwd = 2)

# Histograma 
res <- residuals(model1)
hist(res,
     breaks = 30,
     col = "deepskyblue3",
     border = "black",
     main = "LiekanÅ³ pasiskirstymas",
     xlab = "Liekanos",
     ylab = "Tankis",
     freq = FALSE)                  

mu <- mean(res)
s  <- sd(res)
x <- seq(min(res), max(res), length.out = 200)
lines(x, dnorm(x, mean = mu, sd = s), col = "red", lwd = 2) 


# Normalumo testas
library(nortest)
ad.test(as.numeric(residuals(model1)))


```
Remiantis QQ diagrama ir liekanÅ³ histograma, galima teigti, kad liekanÅ³ pasiskirstymas yra artimas normaliam, taÄiau pastebimi nedideli nukrypimai uodegose (ypaÄ kairÄ—je pusÄ—je). Tai rodo, kad prielaida apie normaliai pasiskirsÄiusias liekanas iÅ¡ esmÄ—s tenkinama, nors pasiskirstymas nÄ—ra visiÅ¡kai idealus.

```{r}
#2.4 DispersijÅ³ lygumas (homoskedastiÅ¡kumas)
library(lmtest)
library(sandwich)

# Breusch-Pagan testas
bptest(model1)

# liekanÅ³ vs prognozuotÅ³ reikÅ¡miÅ³ grafikas
plot(fitted(model1), resid(model1),
     pch = 21, col = "deepskyblue3",
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos reikÅ¡mÄ—s")

abline(h = 0, col = "black", lty = 2, lwd = 2)

# Pridedame LOESS kreivÄ™, kad matytume tendencijÄ…
lines(lowess(fitted(model1), resid(model1)),
      col = "red", lwd = 2)

# KoeficientÅ³ reikÅ¡mÄ—s su heteroskedastiÅ¡kumo korekcija
coeftest(model1, vcov = vcovHC(model1, type = "HC3"))


```

```{r}
#3. IÅ¡skirtys
library(car)

outlierTest(model1) 

influenceIndexPlot(model1, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat")) 

```

```{r}
#3.1. PaÅ¡aliname iÅ¡skirtis ir sukuriame naujÄ… modelÄ¯

# Studentizuotos liekanos
rstud <- rstudent(model1)

# Hat reikÅ¡mÄ—s
hatv <- hatvalues(model1)

# Cook's distance
cooks <- cooks.distance(model1)

# Ä®tartini taÅ¡kai pagal bent vienÄ… kriterijÅ³
suspect <- which(abs(rstud) > 3 | hatv > 0.5 | cooks > (4/length(rstud)))

length(suspect)

# Sukuriame modelÄ¯ be jÅ³
data_clean <- train_data[-suspect, ]
model2 <- update(model1, data = data_clean)


```
Studentizuotos liekanos (rstudent) â†’ rodo, ar stebÄ—sena yra â€neÄ¯prastaâ€œ pagal savo klaidÄ… (outlier pagal Y).

    DaÅ¾niausiai ribos: |rstudent| > 2 (arba > 3, jei daug duomenÅ³).

Hat values (leverage) â†’ rodo, kiek stebÄ—sena turi Ä¯takos savo prognozei (outlier pagal X).

    DidelÄ—s reikÅ¡mÄ—s reiÅ¡kia, kad taÅ¡kas yra â€tolimasâ€œ pagal nepriklausomus kintamuosius.

    Ribos: > 2*(p+1)/n arba > 0.5 (labai didelÄ—), > 0.99 â€“ ekstremali.

Cookâ€™s distance â†’ jungia abu kriterijus (Y ir X) ir parodo, kiek stebÄ—sena keiÄia visÄ… modelÄ¯.

    Ribos: > 4/n arba vizualiai iÅ¡siskiriantys taÅ¡kai.


```{r}
#4. Multikolinearumas:
vif(model2)

```

```{r}
#4.1. Patobulintas modelis (iÅ¡imame kuro sÄ…naudas mieste ir greitkelyje)
model2a <- lm(`CO2 emisijos (g/km)` ~ 
                `VidutinÄ—s kuro sÄ…naudos (l/100km)` + 
                `PavarÅ³ dÄ—Å¾Ä—s tipas` +
                `MarkÄ—`+
                `Kuro tipas` +
                `KÄ—bulo tipas`,
              data = data_clean)

vif(model2a)


```

    Kadangi faktoriai turi skirtingÄ… laisvÄ—s laipsniÅ³ skaiÄiÅ³ (Df = kategorijÅ³ skaiÄius â€“ 1), GVIF reikÅ¡mÄ—s nÄ—ra tiesiogiai palyginamos tarp kintamÅ³jÅ³.

    TodÄ—l daroma korekcija:

GVIF^(1/(2*Df))

    Å i transformacija â€normalizuojaâ€œ GVIF pagal kategorijÅ³ skaiÄiÅ³, kad galÄ—tume palyginti jÄ¯ su Ä¯prastais VIF slenksÄiais (pvz., 4).


```{r}
# 4.2. PaÅ¾ingsninis metodas:
library(MASS)

step_model2 <- stepAIC(model2a, direction = c("both"))

vif(step_model2)

```



```{r}
#5. PrielaidÅ³ tikrinimas patobulintam modeliui:
par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos vs prognozuotos
plot(fitted(model2a), resid(model2a),
     pch = 20, col = "mediumorchid3", bg = "white",
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos")
abline(h = 0, col = "red", lty = 2)

# 2. QQ grafikas
qqnorm(resid(model2a), pch = 20, col = "mediumorchid3", bg = "white",
       main = "LiekanÅ³ QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "StebÄ—tos liekanos")
qqline(resid(model2a), col = "red", lwd = 2)

# 3. Scale-Location
plot(fitted(model2a), sqrt(abs(rstandard(model2a))),
     pch = 20, col = "mediumorchid3", bg = "white",
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "âˆš|Standartizuotos liekanos|",
     main = "Scale-Location")
lines(lowess(fitted(model2a), sqrt(abs(rstandard(model2a)))),
      col = "red", lwd = 2)

# 4. Cook's distance
plot(cooks.distance(model2a), type = "h",
     col = "mediumorchid3", lwd = 2,
     xlab = "StebÄ—jimo indeksas",
     ylab = "Cook's atstumas",
     main = "Ä®takingi taÅ¡kai (Cook's distance)")
abline(h = 4/length(resid(model2a)), col = "red", lty = 2)

par(mfrow = c(1,1))


```
```{r}
#5.2. Liekanos pagal stebÄ—jimÅ³ indeksÄ…

par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos
plot(model2a$residuals, 
     pch = 20, col = "mediumorchid3", bg = "white",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Liekanos",
     main = "Liekanos pagal stebÄ—jimus")
abline(h = 0, col = "black", lty = 2)

# 2. Cook'o atstumas
plot(cooks.distance(model2a), 
     pch = 20, col = "mediumorchid3", bg = "white",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Cook'o atstumas",
     main = "Ä®takingi taÅ¡kai (Cook's distance)")
abline(h = 4/length(resid(model2a)), col = "black", lty = 2)

# 3. Standartizuotos liekanos
plot(rstandard(model2a), 
     pch = 20, col = "mediumorchid3", bg = "white",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Standartizuotos liekanos",
     main = "Standartizuotos liekanos")
abline(h = c(-2,0,2), col = c("black","black","black"), lty = 2)

# 4. Studentizuotos liekanos
plot(rstudent(model2a), 
     pch = 20, col = "mediumorchid3", bg = "white",
     xlab = "StebÄ—jimo indeksas", 
     ylab = "Studentizuotos liekanos",
     main = "Studentizuotos liekanos")
abline(h = c(-3,0,3), col = c("black","black","black"), lty = 2)

par(mfrow = c(1,1))

```
```{r}
# 5.3 LiekanÅ³ normalumas
library(nortest)

res2 <- residuals(model2a)

# QQ grafikas
par(mfrow = c(1, 2), mar = c(4.5, 4.5, 3, 1))
qqnorm(res2,
       pch = 19, col = "mediumorchid3",
       main = "LiekanÅ³ QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "StebÄ—tos liekanos")
qqline(res2, col = "red", lwd = 2)

# Histograma su teorine normalumo kreive
hist(res2,
     breaks = 30,
     col = "mediumorchid3",
     border = "black",
     main = "LiekanÅ³ pasiskirstymas",
     xlab = "Liekanos",
     ylab = "Tankis",
     freq = FALSE)
curve(dnorm(x, mean = mean(res2), sd = sd(res2)),
      col = "red", lwd = 2, add = TRUE)

# Normalumo testai
cat("\n=== MODELIS 2a ===\n")
cat("Andersonâ€“Darling testas:\n")
print(ad.test(as.numeric(res2)))
cat("\nShapiroâ€“Wilk testas:\n")
print(shapiro.test(as.numeric(res2)))



```

```{r}
#5.4 DispersijÅ³ lygumas (homoskedastiÅ¡kumas)
library(lmtest)
library(sandwich)

# Breusch-Pagan testai
bptest(model2a)  

plot(fitted(model2a), resid(model2a),
     pch = 19, col = "mediumorchid3", bg = "white",
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos reikÅ¡mÄ—s")
abline(h = 0, lty = 2, col = "black", lwd = 2)
lines(lowess(fitted(model2a), resid(model2a)),
      col = "red", lwd = 2)

# KoeficientÅ³ reikÅ¡mÄ—s su heteroskedastiÅ¡kumo korekcija
coeftest(model2a, vcov = vcovHC(model2a, type = "HC3"))

```

```{r}
#6. IÅ¡skirtys patobulintam modeliui

outlierTest(model2a)          
influenceIndexPlot(model2a, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat")) 

```

```{r}
#7. Modelio tobulinimas

#7.1. ReikÅ¡mingÅ³ kovarianÄiÅ³ atranka

summary(model2a) 
#paliekam visas
```

```{r}
#7.2. SÄ…veikÅ³ Ä¯traukimas

# Kuriame modelÄ¯ su sÄ…veikomis tarp prasmingÅ³ kintamÅ³jÅ³

model_final <- lm(`CO2 emisijos (g/km)` ~ 
                  `VidutinÄ—s kuro sÄ…naudos (l/100km)` * `Kuro tipas` +
                  `VidutinÄ—s kuro sÄ…naudos (l/100km)` * `KÄ—bulo tipas` +
                  `Kuro tipas` * `PavarÅ³ dÄ—Å¾Ä—s tipas` +
                  `MarkÄ—`,
                data = data_clean)

summary(model_final)

```
* VidutinÄ—s kuro sÄ…naudos Ã— Kuro tipas: Skirtingi kuro tipai (benzinas, dyzelis ir t.t.) turi skirtingÄ… kuro sÄ…naudÅ³ poveikÄ¯ COâ‚‚ emisijoms. Pvz., 1 l/100 km benzino â‰  1 l/100 km dyzelio emisijose.

* VidutinÄ—s kuro sÄ…naudos Ã— KÄ—bulo tipas: Skirtingo tipo automobiliai (sedanas, SUV, heÄbekas) gali turÄ—ti kitokÄ¯ aerodinaminÄ¯ efektyvumÄ…, todÄ—l tas pats sÄ…naudÅ³ lygis skirtingai veikia COâ‚‚.

* Kuro tipas Ã— PavarÅ³ dÄ—Å¾Ä—s tipas: AutomatinÄ—s pavaros gali bÅ«ti maÅ¾iau efektyvios benzinui nei dyzeliui.

IÅ¡vados:ReikÅ¡mingos sÄ…veikos:

VidutinÄ—s kuro sÄ…naudos Ã— Kuro tipas
VidutinÄ—s kuro sÄ…naudos Ã— KÄ—bulo tipas
Kuro tipas Ã— PavarÅ³ dÄ—Å¾Ä—s tipas (ypaÄ su â€Ä®prastas benzinasâ€œ).

TodÄ—l paliekam visas sÄ…veikas.

```{r}
#7.3. ModeliÅ³ palyginimas (ar sÄ…veikos pagerino modelÄ¯)

anova(model2a, model_final)

```
Kadangi:

F = 4.79, p = 4.5 Ã— 10â»â¹ < 0.001

â†’ Galime drÄ…siai teigti, kad:

modelis su sÄ…veikomis statistiÅ¡kai reikÅ¡mingai pagerina paaiÅ¡kinimÄ… lyginant su modeliu be sÄ…veikÅ³.


```{r}
# 8.1. PrognozÄ—s test rinkiniui

# PaÅ¡aliname konkreÄias markes GMC ir SCION
test_data_clean <- subset(test_data,
                          !(`MarkÄ—` %in% c("GMC", "SCION")))

# UÅ¾tikriname, kad faktoriai turi tuos paÄius lygius kaip treniravimo duomenyse
test_data_clean$`MarkÄ—` <- factor(test_data_clean$`MarkÄ—`, levels = levels(data_clean$`MarkÄ—`))
test_data_clean$`Kuro tipas` <- factor(test_data_clean$`Kuro tipas`, levels = levels(data_clean$`Kuro tipas`))
test_data_clean$`PavarÅ³ dÄ—Å¾Ä—s tipas` <- factor(test_data_clean$`PavarÅ³ dÄ—Å¾Ä—s tipas`, levels = levels(data_clean$`PavarÅ³ dÄ—Å¾Ä—s tipas`))
test_data_clean$`KÄ—bulo tipas` <- factor(test_data_clean$`KÄ—bulo tipas`, levels = levels(data_clean$`KÄ—bulo tipas`))

# PrognozÄ—s
test_pred <- predict(model_final, newdata = test_data_clean)

# RezultatÅ³ lentelÄ—
results <- data.frame(
  Tikros = test_data_clean$`CO2 emisijos (g/km)`,
  Prognozuotos = test_pred
)

head(results)


```
```{r}
# 8.2. Modelio tikslumo Ä¯vertinimas (test rinkinyje)

# ApskaiÄiuojame paklaidos rodiklius
library(Metrics)

rmse_val <- rmse(results$Tikros, results$Prognozuotos)
mae_val  <- mae(results$Tikros, results$Prognozuotos)
r2_val   <- cor(results$Tikros, results$Prognozuotos)^2

cat("RMSE:", rmse_val, "\n")
cat("MAE:", mae_val, "\n")
cat("RÂ² (test duomenims):", r2_val, "\n")

```
RMSE (Root Mean Squared Error) â€“ kvadratinÄ— vidutinÄ— paklaida
RMSE = ~2.58 g/km
Tai vidutinÄ— prognozÄ—s klaida kvadratinÄ—s formos (didesnÄ—s klaidos labiau sveriamos).
Kuo maÅ¾esnÄ— reikÅ¡mÄ—, tuo geresnis modelis.
Vertinant COâ‚‚ emisijas (~100â€“200 g/km, priklausomai nuo duomenÅ³), klaida 2.58 yra labai maÅ¾a â†’ modelis tiksliai prognozuoja.

MAE (Mean Absolute Error) â€“ vidutinÄ— absoliuti paklaida
MAE = ~1.66 g/km
Tai vidutinÄ— absoliuti prognozÄ—s klaida, lengviau interpretuojama nei RMSE.
VÄ—lgi, palyginus su COâ‚‚ skalÄ—mis, klaida labai maÅ¾a, t.y. prognozÄ—s labai arti faktiniÅ³ reikÅ¡miÅ³.

RÂ² (Koeficientas determinacijos)
RÂ² = 0.9869 (~98.7%)
Parodo, kiek procentÅ³ duomenÅ³ dispersijos modelis paaiÅ¡kina.
0.9869 reiÅ¡kia, kad modelis paaiÅ¡kina praktiÅ¡kai visÄ… kintamumÄ… COâ‚‚ emisijose treniravimo duomenÅ³ atÅ¾vilgiu.
Tai labai aukÅ¡tas rodiklis, t. y. modelis yra labai geras.

```{r}
#8.3. Grafikas â€“ stebÄ—tos vs prognozuotos reikÅ¡mÄ—s

plot(results$Prognozuotos, results$Tikros,
     xlab = "Prognozuotos reikÅ¡mÄ—s",
     ylab = "StebÄ—tos reikÅ¡mÄ—s",
     main = "Prognozuotos ir stebÄ—tos reikÅ¡mÄ—s",
     pch = 21, bg = "lightblue", col = "darkblue")
abline(0, 1, col = "red", lwd = 2)

```

```{r}
#9. PrognozÄ— naujam automobiliui

naujas <- data.frame(
  check.names = FALSE,  
  "VidutinÄ—s kuro sÄ…naudos (l/100km)" = 8.5,
  "PavarÅ³ dÄ—Å¾Ä—s tipas" = factor("AutomatinÄ— su rankiniu perjungimu", 
                                 levels = levels(train_data$`PavarÅ³ dÄ—Å¾Ä—s tipas`)),
  "Kuro tipas" = factor("Ä®prastas benzinas", 
                        levels = levels(train_data$`Kuro tipas`)),
  "KÄ—bulo tipas" = factor("Lengvieji automobiliai", 
                          levels = levels(train_data$`KÄ—bulo tipas`)),
  "MarkÄ—" = factor("TOYOTA", levels = levels(train_data$MarkÄ—))
)

prognoze <- predict(model_final, newdata = naujas, interval = "prediction")
prognoze

```















