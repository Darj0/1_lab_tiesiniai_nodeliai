


---
title: "tm1lab"
author: "vilte"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
library(dplyr)

data <- read.csv("CO2 Emissions_Canada.csv", header = TRUE)

data <- data[, - (ncol(data) - 1)]

names(data) <- c("Markė",
                 "Modelis",
                 "Kėbulo tipas",
                 "Variklio tūris (l)",
                 "Cilindrų skaičius",
                 "Pavarų dėžės tipas",
                 "Kuro tipas",
                 "Kuro sąnaudos mieste (l/100km)",
                 "Kuro sąnaudos greitkelyje (l/100km)",
                 "Vidutinės kuro sąnaudos (l/100km)",
                 "CO2 emisijos (g/km)")


data$"Kėbulo tipas" <- with(data,
  ifelse(`Kėbulo tipas` %in% c("SUV - SMALL", "SUV - STANDARD"), "SUV",
  ifelse(`Kėbulo tipas` %in% c("MID-SIZE", "COMPACT", "SUBCOMPACT", 
                               "MINICOMPACT", "FULL-SIZE", "TWO-SEATER"),
         "Lengvieji automobiliai",
  ifelse(`Kėbulo tipas` %in% c("STATION WAGON - SMALL", "STATION WAGON - MID-SIZE"),
         "Universalai",
  ifelse(`Kėbulo tipas` %in% c("PICKUP TRUCK - SMALL", "PICKUP TRUCK - STANDARD"),
         "Pikapai",
  ifelse(`Kėbulo tipas` %in% c("MINIVAN", "VAN - PASSENGER", "VAN - CARGO"),
         "Vienatūriai",
  ifelse(`Kėbulo tipas` == "SPECIAL PURPOSE VEHICLE", 
         "Specialieji", NA)))))))


data$"Pavarų dėžės tipas" <- ifelse(grepl("^AM", data$`Pavarų dėžės tipas`), "Automatizuota mechaninė",
                             ifelse(grepl("^AS", data$`Pavarų dėžės tipas`), "Automatinė su rankiniu perjungimu",
                             ifelse(grepl("^AV", data$`Pavarų dėžės tipas`), "Bepakopė (CVT)",
                             ifelse(grepl("^A",  data$`Pavarų dėžės tipas`), "Automatinė",
                             ifelse(grepl("^M",  data$`Pavarų dėžės tipas`), "Mechaninė", NA)))))


data$"Kuro tipas" <- ifelse(data$`Kuro tipas` == "X", "Įprastas benzinas",
                     ifelse(data$`Kuro tipas` == "Z", "Aukštos kokybės benzinas",
                     ifelse(data$`Kuro tipas` == "D", "Dyzelinas",
                     ifelse(data$`Kuro tipas` == "E", "Etanolis (E85)",
                     ifelse(data$`Kuro tipas` == "N", "Gamtinės dujos", NA)))))


data <- data %>%
  filter(`Variklio tūris (l)` == 2.0)%>%
  droplevels()



```

```{r}
# Duomenų išvalymas:
# Patikrinam, kiek yra NA reikšmių
colSums(is.na(data))

# Funkcija, kuri patikrina išskirtis pagal IQR
check_outliers <- function(x, coef = 1.5) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - coef * IQR
  upper <- Q3 + coef * IQR
  sum(x < lower | x > upper, na.rm = TRUE) 
}

# Funkcija, kuri grąžina loginį vektorių (TRUE = ekstremali reikšmė)
is_extreme <- function(x, coef = 3) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - coef * IQR
  upper <- Q3 + coef * IQR
  (x < lower) | (x > upper)
}

# Pasirenkam kiekybinius kintamuosius
numeric_vars <- c("Vidutinės kuro sąnaudos (l/100km)",
                  "Kuro sąnaudos greitkelyje (l/100km)",
                  "Kuro sąnaudos mieste (l/100km)",
                  "Cilindrų skaičius",
                  "CO2 emisijos (g/km)")

# Lentelė su išskirčių skaičiumi
outlier_summary <- data.frame(
  Outliers_1.5IQR = sapply(data[numeric_vars], check_outliers, coef = 1.5),
  Outliers_3IQR   = sapply(data[numeric_vars], check_outliers, coef = 3)
)

print(outlier_summary)

cat("Pradinė imtis:", nrow(data), "eilučių\n")

# Pašalinam ekstremalias reikšmes (pagal 3*IQR)
extreme_list <- lapply(data[numeric_vars], is_extreme, coef = 3)
rows_to_remove <- Reduce("|", extreme_list)   
data <- data[!rows_to_remove, ]

cat("Pašalinta išskirčių:", sum(rows_to_remove), "eilučių\n")
cat("Likusi imtis:", nrow(data), "eilučių\n")


```


```{r}
# Histograma su CO2 emisijomis
hist(data$`CO2 emisijos (g/km)`,
     breaks = 40,
     probability = TRUE,
     main = "Automobilių CO2 emisijų pasiskirstymo histograma",
     xlab = "CO2 emisijos (g/km)",
     ylab = "Tankis",
     col = "lightblue",
     border = "black")

# Normalioji kreivė
x <- seq(min(data$`CO2 emisijos (g/km)`, na.rm=TRUE), max(data$`CO2 emisijos (g/km)`, na.rm=TRUE), length=100)
y <- dnorm(x, 
           mean=mean(data$`CO2 emisijos (g/km)`, na.rm=TRUE), 
           sd=sd(data$`CO2 emisijos (g/km)`, na.rm=TRUE))
lines(x, y, col="red", lwd=2)

legend(x = 5.75, y = 1.93,
       legend = c("CO2 emisijų pasiskirstymas", "Normalumo kreivė"),
       pch    = c(22, NA),              
       pt.cex = c(2, NA),               
       col    = c("black", "red"),      
       pt.bg  = c("lightblue", NA),     
       pt.lwd = c(1.5, NA),             
       lwd    = c(NA, 2),
       bty    = "n")

#QQ grafikas
library(car)

qqPlot(data$`CO2 emisijos (g/km)`, 
       dist = "norm",
       main = "QQ CO2 emisijų grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos CO2 emisijos (g/km)")

```
```{r}
# Statistinis Andersono-Darlingo testas
library(nortest)
ad.test(data$`CO2 emisijos (g/km)`)
```

```{r}
library(corrplot)
library(GGally)
library(ggplot2)

# 1. Paruošiami kiekybiniai kintamieji
numeric_vars <- data[, c("Kuro sąnaudos mieste (l/100km)",
                          "Kuro sąnaudos greitkelyje (l/100km)",
                          "Vidutinės kuro sąnaudos (l/100km)",
                          "CO2 emisijos (g/km)")]

colnames(numeric_vars) <- c("Kuro sąnaudos\nmieste (l/100km)",
                            "Kuro sąnaudos\ngreitkelyje (l/100km)",
                            "Vidutinės kuro\nsąnaudos (l/100km)",
                            "CO2 emisijos (g/km)")

# 2. Koreliacijų matrica
cor_matrix <- cor(numeric_vars, use = "complete.obs")

# 3. Heatmap su numbers metodu
corrplot(cor_matrix,
         method = "number",  
         type = "upper",      
         tl.col = "black",    
         tl.srt = 90,         
         number.cex = 0.8,    
         addCoef.col = "black") 

# 4. Sklaidos diagramų matrica
upper_fun <- function(data, mapping, ...) {
  ggplot(data, mapping) +
    geom_point(alpha = 0.5, color = "deepskyblue3") +         
    geom_smooth(method = "lm", se = FALSE, color = "red", lwd = 1) + 
    theme_minimal()
}

diag_fun <- function(data, mapping, ...) {
  var <- as_label(mapping$x)
  ggplot() +
    annotate("text", x = 0.5, y = 0.5, label = var, size = 4, fontface = "bold") +
    theme_void()
}

p <- suppressMessages(
  suppressWarnings(
    ggpairs(numeric_vars,
            upper = list(continuous = upper_fun),   
            lower = list(continuous = "blank"),     
            diag  = list(continuous = "blank"),    
            progress = FALSE) +
      ggtitle("Sklaidos diagramų matrica") +
      theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  )
)

# Išsaugom kaip PNG 
ggsave(filename = "scatter.png",
plot = p, width = 12, height = 12, dpi = 300)


```


```{r}
library(dplyr)
library(ggplot2)
library(colorspace)

dep_var <- "CO2 emisijos (g/km)"

# ===== Funkcija kategoriniams kintamiesiems =====
plot_box_rainbow <- function(data, var_name, title) {
  n_levels <- length(unique(data[[var_name]]))
  
  ggplot(data, aes(x = .data[[var_name]], 
                   y = `CO2 emisijos (g/km)`, 
                   fill = .data[[var_name]])) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = rainbow_hcl(n_levels, c = 60, l = 80)) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          legend.position = "none",
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5)
          )
}

#  Markės
p2 <- plot_box_rainbow(data, "Markė", "CO2 emisijos pagal markes") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p2)

#  Kėbulo tipas
p3 <- plot_box_rainbow(data, "Kėbulo tipas", "CO2 emisijos pagal kėbulo tipą")
print(p3)

#  Pavarų dėžės tipas
p4 <- plot_box_rainbow(data, "Pavarų dėžės tipas", "CO2 emisijos pagal pavarų dėžės tipą")
print(p4)

#  Kuro tipas
data <- data %>%
  filter(`Kuro tipas` != "Gamtinės dujos")

p5 <- plot_box_rainbow(data, "Kuro tipas", "CO2 emisijos pagal kuro tipą") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))  
print(p5)


```


```{r}
library(dplyr)

# Funkcija dažnių lentelei 
freq_table_df <- function(data, var_name) {
  data %>%
    group_by(.data[[var_name]]) %>%
    summarise(Dažnis = n(), .groups = "drop") %>%
    arrange(desc(Dažnis))
}

# Markės
freq_marke <- freq_table_df(data, "Markė")

# Kėbulo tipas
freq_kebulas <- freq_table_df(data, "Kėbulo tipas")

# Pavarų dėžės tipas
freq_pavaros <- freq_table_df(data, "Pavarų dėžės tipas")

# Kuro tipas
freq_kuras <- freq_table_df(data, "Kuro tipas")

freq_marke
freq_kebulas
freq_pavaros
freq_kuras
```


```{r}
library(dplyr)
library(ggplot2)

# Funkcija vidurkio su dispersija grafiko sudarymui
mean_point_plot <- function(data, var_name, filter_values = NULL, color = "black", title = NULL) {
  df <- data
  if (!is.null(filter_values)) {
    df <- df %>% filter(.data[[var_name]] %in% filter_values)
  }
  
  summary_df <- df %>%
    group_by(.data[[var_name]]) %>%
    summarise(
      mean_CO2 = mean(`CO2 emisijos (g/km)`, na.rm = TRUE),
      sd_CO2   = sd(`CO2 emisijos (g/km)`, na.rm = TRUE),
      n        = n(),
      .groups  = "drop"
    ) %>%
    mutate(se = sd_CO2 / sqrt(n))
  
  ggplot(summary_df, aes(x = .data[[var_name]], y = mean_CO2)) +
    geom_point(size = 3, color = color) +
    geom_errorbar(aes(ymin = mean_CO2 - sd_CO2, ymax = mean_CO2 + sd_CO2),
                  width = 0.2, color = color) +
    theme_minimal() +
    labs(title = title,
         x = var_name,
         y = "CO2 emisijos (g/km)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.line.x = element_line(color = "black", linewidth = 0.5),
          axis.line.y = element_line(color = "black", linewidth = 0.5),
          axis.ticks = element_line(color = "black", linewidth = 0.5))
}

# Markės 
p_mean_marke <- mean_point_plot(data, "Markė",
                                color = "navy",
                                title = "Vidutinės CO2 emisijos pagal markes") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))  
print(p_mean_marke)


# Kėbulo tipas 
p_mean_kebulas <- mean_point_plot(data, "Kėbulo tipas",
                                  color = "black",
                                  title = "Vidutinės CO2 emisijos pagal kėbulo tipą")
print(p_mean_kebulas)

# Pavarų dėžės tipas 
p_mean_pavare <- mean_point_plot(data, "Pavarų dėžės tipas",
                                 color = "darkred",
                                 title = "Vidutinės CO2 emisijos pagal pavarų dėžės tipą")
print(p_mean_pavare)

# Kuro tipas 
p_mean_kuras <- mean_point_plot(data, "Kuro tipas",
                                color = "darkgreen",
                                title = "Vidutinės CO2 emisijos pagal kuro tipą") 
print(p_mean_kuras)


```

```{r}
set.seed(123) 
data <- data[sample(nrow(data)), ]

train_index <- sample(1:nrow(data), 0.8 * nrow(data))

train_data <- data[train_index, ]
test_data <- data[-train_index, ]

cat("Eilučių skaičius pradiniuose duomenyse:", nrow(data), "\n")
cat("Eilučių skaičius treniravimo aibėje:", nrow(train_data), "\n")
cat("Eilučių skaičius testavimo aibėje:", nrow(test_data), "\n")

```



```{r}
# 1. Pradinis modelis ir liekanų gavimas
# Pakeičiame kategorinius kintamuosius į faktorius
train_data$`Pavarų dėžės tipas` <- as.factor(train_data$`Pavarų dėžės tipas`)
train_data$`Kuro tipas`         <- as.factor(train_data$`Kuro tipas`)
train_data$`Markė`              <- as.factor(train_data$`Markė`)
train_data$`Kėbulo tipas`       <- as.factor(train_data$`Kėbulo tipas`)


# Sukuriame pradinį modelį 
model1 <- lm(`CO2 emisijos (g/km)` ~ 
               `Vidutinės kuro sąnaudos (l/100km)` + 
               `Kuro sąnaudos mieste (l/100km)` + 
               `Kuro sąnaudos greitkelyje (l/100km)` + 
               `Pavarų dėžės tipas` +
               `Kuro tipas` +
               `Markė`+
               `Kėbulo tipas`,
             data = train_data)

# Išsaugome liekanas ir diagnostinius rodiklius
train_data <- train_data %>%
  mutate(fitted = fitted(model1),
         resid = residuals(model1),
         rstd = rstandard(model1),
         rstud = rstudent(model1),
         hat = hatvalues(model1),
         cooks = cooks.distance(model1),
         obs = row_number())

```

```{r}
# 2. Prielaidų tikrinimas
par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos vs prognozuotos reikšmės
plot(fitted(model1), resid(model1),
     pch = 21, col = "deepskyblue3",
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos reikšmės")
abline(h = 0, lty = 2, col = "red")

# 2. QQ grafikas
qqnorm(resid(model1), pch = 21, col = "deepskyblue3",
       main = "Liekanų QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos liekanos")
qqline(resid(model1), col = "red", lwd = 2)

# 3. Scale-Location (standartizuotos liekanos vs prognozuotos)
plot(fitted(model1), sqrt(abs(rstandard(model1))),
     pch = 21, col = "deepskyblue3",
     xlab = "Prognozuotos reikšmės",
     ylab = "Standartizuotos liekanos",
     main = "Scale-Location grafikas")
lines(lowess(fitted(model1), sqrt(abs(rstandard(model1)))),
      col = "red", lwd = 2)

# 4. Cook's distance
plot(cooks.distance(model1), type = "h",
     col = "deepskyblue3", lwd = 2,
     xlab = "Stebėjimo numeris",
     ylab = "Cook's atstumas",
     main = "Įtakingi taškai (Cook's distance)")
abline(h = 4/length(resid(model1)), col = "red", lty = 2)

par(mfrow = c(1,1))


```
1. Residuals vs Fitted:
Liekanų sklaida rodo, kad modelio prielaida apie tiesinį ryšį daugmaž tenkinama, tačiau yra šiek tiek heteroskedastiškumo — didesni CO₂ rodikliai turi kiek didesnį liekanų išsibarstymą.
Tai gali būti dėl to, kad skirtingos markės ar kuro rūšys natūraliai turi skirtingus sklaidos lygius (pvz., sportiniai modeliai turi labiau kintamus CO₂ rodiklius).

2. QQ grafikas:
Liekanos daugmaž normalios, bet yra šiek tiek „uodegos“ dešinėje — t. y. kai kurie automobiliai turi labiau nei tikėtasi teigiamas liekanas (prognozuotas CO₂ < faktinis).
Tai natūralu, nes tam tikros markės (pvz., didesni, galingesni varikliai) gali būti sunkiau tiksliai aprašomos tiesiniu modeliu.

3. Scale-Location grafikas:
Kreivė nėra visiškai horizontali — matosi, kad didėjant prognozuotai CO₂ emisijai, liekanų išsibarstymas šiek tiek didėja.
Tai reiškia, kad heteroskedastiškumas šiek tiek padidėjęs. Kitaip tariant, modelis šiek tiek mažiau tiksliai prognozuoja didelius CO₂ rodiklius.
Tačiau bendrai tendencija nėra labai stipri — modelis vis dar pakankamai stabilus.

4.Cook's distance:
Modelyje yra keletas įtakingų stebėjimų — greičiausiai tai automobiliai su ypač didelėmis emisijomis (pvz., sportiniai arba hibridiniai su dideliu varikliu).
Juos verta patikrinti atskirai — ar jie realūs, ar galbūt klaidingi duomenys.
Tačiau šie taškai nekenkia modeliui drastiškai.

```{r}
#2.2. Liekanos pagal stebėjimų indeksą
par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos
plot(model1$residuals, 
     pch = 21, col = "red",
     xlab = "Stebėjimo numeris", 
     ylab = "Liekanos",
     main = "Liekanos pagal stebėjimus")
abline(h = 0, col = "black", lty = 2, lwd = 2)

# 2. Cook's atstumas
plot(cooks.distance(model1), 
     pch = 21, col = "deepskyblue3",
     xlab = "Stebėjimo numeris", 
     ylab = "Cook's atstumas",
     main = "Įtakingi taškai (Cook's distance)")
abline(h = 4/length(resid(model1)), col = "black", lty = 2, lwd = 2)

# 3. Standartizuotos liekanos
plot(rstandard(model1), 
     pch = 21, col = "deepskyblue3",
     xlab = "Stebėjimo numeris", 
     ylab = "Standartizuotos liekanos",
     main = "Standartizuotos liekanos")
abline(h = c(-2,0,2), col = c("black","black","black"), lty = c(2,2,2))

# 4. Studentizuotos liekanos
plot(rstudent(model1), 
     pch = 21, col = "deepskyblue3",
     xlab = "Stebėjimo numeris", 
     ylab = "Studentizuotos liekanos",
     main = "Studentizuotos liekanos")
abline(h = c(-3,0,3), col = c("black","black","black"), lty = c(2,2,2))

par(mfrow = c(1,1))


```
Liekanos svyruoja aplink nulį be aiškios struktūros.
🔹 Nėra akivaizdžių grupavimų ar sekų, kas rodo, kad duomenys nėra priklausomi vienas nuo kito (t. y. nėra autokoreliacijos).

→ Išvada:
Modelio prielaida apie atsitiktines, nepriklausomas klaidas tenkinama.


```{r}
#2.3 Liekanų normalumas
par(mfrow = c(1,2), mar = c(4.5,4.5,3,1))

# QQ grafikas
qqnorm(residuals(model1),
       pch = 21, col = "deepskyblue3",
       main = "Liekanų QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos liekanos")
qqline(residuals(model1), col = "red", lwd = 2)

# Liekanų histograma
hist(residuals(model1),
     breaks = 30,
     col = "deepskyblue3",
     border = "black",
     main = "Liekanų pasiskirstymas",
     xlab = "Liekanos",
     ylab = "Dažnis")

# Normalumo testas
library(nortest)
ad.test(as.numeric(residuals(model1)))



```
Remiantis QQ diagrama ir liekanų histograma, galima teigti, kad liekanų pasiskirstymas yra artimas normaliam, tačiau pastebimi nedideli nukrypimai uodegose (ypač kairėje pusėje). Tai rodo, kad prielaida apie normaliai pasiskirsčiusias liekanas iš esmės tenkinama, nors pasiskirstymas nėra visiškai idealus.

```{r}
#2.4 Dispersijų lygumas (homoskedastiškumas)
library(lmtest)
library(sandwich)

# Breusch-Pagan testas
bptest(model1)

# liekanų vs prognozuotų reikšmių grafikas
plot(fitted(model1), resid(model1),
     pch = 21, col = "deepskyblue3",
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos reikšmės")

abline(h = 0, col = "black", lty = 2, lwd = 2)

# Pridedame LOESS kreivę, kad matytume tendenciją
lines(lowess(fitted(model1), resid(model1)),
      col = "red", lwd = 2)

# Koeficientų reikšmės su heteroskedastiškumo korekcija
coeftest(model1, vcov = vcovHC(model1, type = "HC3"))


```

```{r}
#3. Išskirtys
library(car)

outlierTest(model1) 

influenceIndexPlot(model1, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat")) 

```

```{r}
#3.1. Pašaliname išskirtis ir sukuriame naują modelį

# Studentizuotos liekanos
rstud <- rstudent(model1)

# Hat reikšmės
hatv <- hatvalues(model1)

# Cook's distance
cooks <- cooks.distance(model1)

# Įtartini taškai pagal bent vieną kriterijų
suspect <- which(abs(rstud) > 3 | hatv > 0.5 | cooks > (4/length(rstud)))

length(suspect)

# Sukuriame modelį be jų
data_clean <- train_data[-suspect, ]
model2 <- update(model1, data = data_clean)


```
Studentizuotos liekanos (rstudent) → rodo, ar stebėsena yra „neįprasta“ pagal savo klaidą (outlier pagal Y).

    Dažniausiai ribos: |rstudent| > 2 (arba > 3, jei daug duomenų).

Hat values (leverage) → rodo, kiek stebėsena turi įtakos savo prognozei (outlier pagal X).

    Didelės reikšmės reiškia, kad taškas yra „tolimas“ pagal nepriklausomus kintamuosius.

    Ribos: > 2*(p+1)/n arba > 0.5 (labai didelė), > 0.99 – ekstremali.

Cook’s distance → jungia abu kriterijus (Y ir X) ir parodo, kiek stebėsena keičia visą modelį.

    Ribos: > 4/n arba vizualiai išsiskiriantys taškai.


```{r}
#4. Multikolinearumas:
vif(model2)

```

```{r}
#4.1. Patobulintas modelis (išimame kuro sąnaudas mieste ir greitkelyje)
model2a <- lm(`CO2 emisijos (g/km)` ~ 
                `Vidutinės kuro sąnaudos (l/100km)` + 
                `Pavarų dėžės tipas` +
                `Markė`+
                `Kuro tipas` +
                `Kėbulo tipas`,
              data = data_clean)

vif(model2a)


```

    Kadangi faktoriai turi skirtingą laisvės laipsnių skaičių (Df = kategorijų skaičius – 1), GVIF reikšmės nėra tiesiogiai palyginamos tarp kintamųjų.

    Todėl daroma korekcija:

GVIF^(1/(2*Df))

    Ši transformacija „normalizuoja“ GVIF pagal kategorijų skaičių, kad galėtume palyginti jį su įprastais VIF slenksčiais (pvz., 4).


```{r}
# 4.2. Pažingsninis metodas:
library(MASS)

step_model2 <- stepAIC(model2a, direction = c("both"))

vif(step_model2)

```

Multikolinearumo problema buvo sprendžiama dviem būdais: rankiniu būdu ir taikant pažingsninę regresiją. Rankiniu būdu pašalinus kuro sąnaudas mieste, kuro sąnaudas greitkelyje ir cilindrų skaičių, VIF reikšmės sumažėjo iki < 4, todėl multikolinearumo problema buvo išspręsta. Tuo tarpu pažingsninė regresija, optimizuodama pagal AIC, paliko kintamuosius, kurių VIF išliko aukštas, todėl ši procedūra multikolinearumo problemos neišsprendė. Tolesnei analizei pasirinkti rankiniu būdu sudaryti modeliai, nes jie geriau atitiko prielaidas.

```{r}
#5. Prielaidų tikrinimas patobulintam modeliui:
par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos vs prognozuotos
plot(fitted(model2a), resid(model2a),
     pch = 20, col = "darkviolet", bg = "white",
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos")
abline(h = 0, col = "red", lty = 2)

# 2. QQ grafikas
qqnorm(resid(model2a), pch = 20, col = "darkviolet", bg = "white",
       main = "Liekanų QQ grafikas",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos liekanos")
qqline(resid(model2a), col = "red", lwd = 2)

# 3. Scale-Location
plot(fitted(model2a), sqrt(abs(rstandard(model2a))),
     pch = 20, col = "darkviolet", bg = "white",
     xlab = "Prognozuotos reikšmės",
     ylab = "√|Standartizuotos liekanos|",
     main = "Scale-Location")
lines(lowess(fitted(model2a), sqrt(abs(rstandard(model2a)))),
      col = "red", lwd = 2)

# 4. Cook's distance
plot(cooks.distance(model2a), type = "h",
     col = "darkviolet", lwd = 2,
     xlab = "Stebėjimo numeris",
     ylab = "Cook's atstumas",
     main = "Įtakingi taškai (Cook's distance)")
abline(h = 4/length(resid(model2a)), col = "red", lty = 2)

par(mfrow = c(1,1))


```
```{r}
#5.2. Liekanos pagal stebėjimų indeksą

par(mfrow = c(2,2), mar = c(4.5,4.5,3,1))

# 1. Liekanos
plot(model2a$residuals, 
     pch = 20, col = "darkviolet", bg = "white",
     xlab = "Stebėjimo numeris", 
     ylab = "Liekanos",
     main = "Liekanos pagal stebėjimus")
abline(h = 0, col = "black", lty = 2)

# 2. Cook'o atstumas
plot(cooks.distance(model2a), 
     pch = 20, col = "darkviolet", bg = "white",
     xlab = "Stebėjimo numeris", 
     ylab = "Cook'o atstumas",
     main = "Įtakingi taškai (Cook's distance)")
abline(h = 4/length(resid(model2a)), col = "black", lty = 2)

# 3. Standartizuotos liekanos
plot(rstandard(model2a), 
     pch = 20, col = "darkviolet", bg = "white",
     xlab = "Stebėjimo numeris", 
     ylab = "Standartizuotos liekanos",
     main = "Standartizuotos liekanos")
abline(h = c(-2,0,2), col = c("black","black","black"), lty = 2)

# 4. Studentizuotos liekanos
plot(rstudent(model2a), 
     pch = 20, col = "darkviolet", bg = "white",
     xlab = "Stebėjimo numeris", 
     ylab = "Studentizuotos liekanos",
     main = "Studentizuotos liekanos")
abline(h = c(-3,0,3), col = c("black","black","black"), lty = 2)

par(mfrow = c(1,1))

```
```{r}
# 5.3 Liekanų normalumas
library(nortest)

res2 <- residuals(model2a)

# QQ grafikas
par(mfrow = c(1, 2), mar = c(4.5, 4.5, 3, 1))
qqnorm(res2,
       pch = 19, col = "darkviolet",
       main = "Liekanų QQ grafikas (modelis 2a)",
       xlab = "Teoriniai kvantiliai",
       ylab = "Stebėtos liekanos")
qqline(res2, col = "red", lwd = 2)

# Histograma su teorine normalumo kreive
hist(res2,
     breaks = 30,
     col = "darkviolet",
     border = "black",
     main = "Liekanų pasiskirstymas (modelis 2a)",
     xlab = "Liekanos",
     ylab = "Dažnis",
     freq = FALSE)
curve(dnorm(x, mean = mean(res2), sd = sd(res2)),
      col = "red", lwd = 2, add = TRUE)

# Normalumo testai
cat("\n=== MODELIS 2a ===\n")
cat("Anderson–Darling testas:\n")
print(ad.test(as.numeric(res2)))
cat("\nShapiro–Wilk testas:\n")
print(shapiro.test(as.numeric(res2)))



```

```{r}
#5.4 Dispersijų lygumas (homoskedastiškumas)
library(lmtest)
library(sandwich)

# Breusch-Pagan testai
bptest(model2a)  

plot(fitted(model2a), resid(model2a),
     pch = 19, col = "darkviolet", bg = "white",
     xlab = "Prognozuotos reikšmės",
     ylab = "Liekanos",
     main = "Liekanos ir prognozuotos reikšmės")
abline(h = 0, lty = 2, col = "black", lwd = 2)
lines(lowess(fitted(model2a), resid(model2a)),
      col = "red", lwd = 2)

# Koeficientų reikšmės su heteroskedastiškumo korekcija
coeftest(model1a, vcov = vcovHC(model1a, type = "HC3"))
coeftest(model2a, vcov = vcovHC(model2a, type = "HC3"))

```
```{r}
#6. Išskirtys patobulintam modeliui

outlierTest(model2a)          
influenceIndexPlot(model2a, id=list(method="y", n=3), vars=c("Cook", "Studentized", "hat")) 

```
```{r}
#7. Modelio tobulinimas

#7.1. Reikšmingų kovariančių atranka

summary(model2a)
```

```{r}
#7.2. Dalinė koreliacija

#library(ppcor)

#vars1 <- data[, c("CO2 emisijos (g/km)",
#                       "Vidutinės kuro sąnaudos (l/100km)")]

#pcor(vars1)

#vars2 <- data_clean[, c("CO2 emisijos (g/km)",
#                       "Vidutinės kuro sąnaudos (l/100km)")]

#pcor(vars2)
```

```{r}
#7.3. Prognozuotos ir stebėtos reikšmės


plot(fitted(model2a), data_clean$`CO2 emisijos (g/km)`,
     xlab="Prognozuotos reikšmės", ylab="Stebėtos reikšmės",
     main="Antras modelis", pch=21, col="purple")
abline(0,1,col="red", lwd=2)


```
Išvados: renkamės Model2 (be išskirčių), nes R^2 didesnis bei iš grafikų matosi, kad prognozuotos reikšmės labiau atitinka stebėtas.


```{r}

# Prognozės train rinkiniui
train_pred <- predict(model1a, newdata = train_data, interval = "prediction")

# Palyginame prognozuotas ir tikras reikšmes
head(cbind(Tikros = train_data$`CO2 emisijos (g/km)`, Prognozuotos = train_pred[, "fit"]))

# Galima vizualizuoti
plot(train_pred[, "fit"], train_data$`CO2 emisijos (g/km)`,
     xlab = "Prognozuotos reikšmės", ylab = "Tikros reikšmės",
     main = "Prognozės train rinkiniui", pch = 21, col = "blue")
abline(0,1, col="red", lwd=2)




```


```{r}
#8. Interpretacija ir prognozė: 

# Determinacijos koeficientas
cat("R^2 reikšmė:", summary(model2a)$r.squared, "\n")
cat("Adj. R^2 reikšmė:", summary(model2a)$adj.r.squared, "\n")

# Reikšmingiausi kintamieji pagal p reikšmes
coef_table <- summary(model2a)$coefficients
sig_vars <- coef_table[coef_table[,4] < 0.05, ]
sig_vars

# Prognozė naujam automobiliui
naujas <- data.frame(
  check.names = FALSE,  
  "Vidutinės kuro sąnaudos (l/100km)" = 8,
  "Variklio tūris (l)" = 2.0,
  "Pavarų dėžės tipas" = factor("Automatinė su rankiniu perjungimu", 
                                 levels = levels(data_clean$`Pavarų dėžės tipas`)),
  "Kuro tipas" = factor("Įprastas benzinas", 
                        levels = levels(data_clean$`Kuro tipas`)),
  "Kėbulo tipas" = factor("Lengvieji automobiliai", 
                          levels = levels(data_clean$`Kėbulo tipas`)),
  "Markė" = factor("TOYOTA", levels = levels(data_clean$Markė))
)

prognoze <- predict(model2a, newdata = naujas, interval = "prediction")
prognoze

```





